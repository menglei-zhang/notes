HTML 标签
三大标签 title description keywords
icon图标下载  https://www.jd.com/favicon.ico
	图片转换成ico图标	http://www.bitbug.net
ico图标下载  http://icomoon.io
引入ico图标  <link rel="shortcut icon" href="">
{
	font-family:"icomoon";
	font-style:normal;
	color:  ;
	font-size:  ;
}

// 块级元素	div/h/p/ul/ol/li等
// 行内元素	span/a/strong/b/em/i/del/s/ins/u/等
// 行内块元素 input/img/td
块-->行内 display:inline;
行内-->块 display:block;
块-->行内块 display:line-block;
行内-->行内块 display:line-block;

<h></h>  // 标题标签   h1-h6  h1一般给logo使用
<p style="text-aligh:center;display:inline;float:right;margin-right:30px">我是段落标签</p>
<hr/>    // 水平线标签
<br width="500px" color="red"/>	 // 换行标签
<div></div>
<span></span>
加  粗：<b></b>	<strong></strong>
倾  斜：<i></i>	<em></em>
删  除：<s></s>	<del></del>
下划线：<u></u>	<ins></ins>
空格:&nbsp;	 
<:   &lt;	
>:   &gt;	
&:   &amp;	
版权符号:  &copy;
<img src="" title="" alt="" width=""/>
<a href="https://www.baidu.com" target="_blank">百度</a>  
// 外部链接   href="绝对路径"
// 内部链接	  href="相对路径"
// 锚点定位   
<a href="#id"></a>		// 跳转到页面中对用的id的位置
<base target="_blank">
// 有序列表  
<ul>
	<li></li>
	<li></li>
	<li></li>
</ul>
// 无序列表
<ol>
	<li></li>
	<li></li>
	<li></li>
</ol>
// ol和ul中只能放li，但是li中可以放其他标签
// table表格
<table>
	<tr>
		<th></th>
		<th></th>   // th表头  文本加粗、居中
	</tr>
	<tr>
		<td></td>	// td 单元格标签  文本局左
		<td></td>
	</tr>
	<tr>
		<td></td>
		<td></td>
	</tr>
</table>

table{
	border-collapse:collapse;
}
// rowspan 跨行合并	<th rowspan="2"></th>
// colspan 跨列合并	<th colspan="2"></th>

表单标签
// 表单控件	 提示信息	表单域
input控件 text/password/radio checked="checked"/chekbox checked="checked"/button/submit/reset/image/file/textarea
select
<select>
	<option></option>
	<option selected="selected"></option>
	<option></option>
</select>

// 文本域	textarea
// 表单域	form
// 文件域	file


<base target="_blank">

### css

<link type="text/cee" rel="stylesheet" href="">

### 定位
	相对定位  position:relative;
	绝对定位  position:absolute;
	固定定位  position:fixed;

### 背景图片
	background: #00FF00 url(bgimage.gif) no-repeat fixed top;

rgb格式	#××××××

<style>
	border:1px solid red;
	color:red !important;
	box-shadow:5px 5px 5px rgba(0,0,0,0.3);
	margin-left:10px;
	margin:0 auto;
	border-radius:50%;
	background: #00FF00 url(bgimage.gif) no-repeat fixed top;

	li{
		list-style:none;
	}

	input{
		border:0;
		outline:none;
	}
	a{
		text-decoration:none
	}
	a:hover{
		color:red;
	}
	div:first-child{

	}
	div:nth-child(2){

	}
	div:last-child{

	}
	
	// 清楚浮动
	.clearfix before,
	.clearfix after{
		content:"";
		display:table;
	}
	clearfix:after{
		clear:both;
	}
	.clearfix{
		zoom:1;
	}
</style>

API(application Programming Interface)应用程序编程接口 预先定义好的函数
任何开发语言都有自己的API
API的特征是输入和输出（I/O)
API的使用方法（console.log()）
WEB API浏览器提供的接口
Javascript包括ECOAscript、BOM、DOM
## DOM、BOM、jQuery
	DOM：文档对象模型，描述了处理网页内容的方法和接口。最根本对象是document（window.document）。
	由于DOM的操作对象是文档，所以DOM和浏览器没有直接关系。
	部署在服务器上的文件夹、右键查看源代码等。
	BOM：浏览器对象模型，描述了与浏览器进行交互的方法和接口。由navigator、history、screen、location、window五个对象组成的，最根本对象是window。
	用来获取或设置浏览器的属性、行为，例如：新建窗口、获取屏幕分辨率、浏览器版本号等。
	浏览器的标签页、地址栏、搜索栏、菜单栏、滚动条等。
	DOM是W3C的标准，BOM没有相关标准。

	DOM 中的顶级对象:docuemnt---页面中的顶级对象.docuemnt点出来的是DOM中的属性和方法
	BOM 中的顶级对象:window----浏览器中的顶级对象.window点出来的是浏览器中的属性和方法
	jQuery 的顶级对象:jQuery---$.$点出来的是jQuery中的方法

	BOM（broswer object model）浏览器对象模型
		弹出新的浏览器窗口
		移动、关闭浏览器窗口，以及调节浏览器窗口的大小
		提供用户屏幕分辨率详细信息的屏幕对象
	DOM（document object model）文档对象模型
		把文档抽离成对象，对象具有属性和方法
		与HTML都是树形结构
### 事件：
	onload ：当页面载入完毕后触发
	onfocus ：当获得焦点时触发
	onblur ：当失去焦点时触发
	onmouseover ：当鼠标悬浮时触发
	onmouseout ：当鼠标离开时触发
	onmousedown ：当鼠标按下时触发
	onmouseup ：当鼠标弹起时触发
	onmousemove ：当鼠标移动时触发
	onclick ： 当单击时触发
	onkeypress：键被按下后又被释放，输入了字符
	onkeydown：当键盘按下时触发
	onkeyup ：当键盘弹起时触发
	onsubmit：当表单提交时触发
	onchange： 当内容改变且失去焦点时触发
	oninput ： 当内容改变时触发
	onreset ：当表单重置时触发（<input type='reset' value='重置' />）

### 事件绑定
	事件的绑定有三种形式：行内绑定、动态绑定、事件监听
	




节点（node）（网页中所有的内容都是节点）属性节点、元素节点、文本节点、注释节点
节点对用的三个重要属性：NodeName、NodeType、NodeValue
文档：一个网页可以成为一个文档
节点：网页中所有的内容都是节点
元素：网页送的标签
属性：标签的属性
parentNode  // 父节点  只有一个
childNodes  // 子节点	有多个
firstChild  // 第一个子节点
children    // 子元素
console.log(box.childNodes);   // 打印所有的子节点
console.log(box.children);
console.log(box.parentNode);
nextsibling   // 下一个兄弟节点
previousSibling  // 下一个兄弟节点
firstElementChild  // 第一个子元素   有兼容性，IE9后才支持  last 
nextElementSibling   // 下一个兄弟元素   
previousElementSibling  // 上一个兄弟元素


DOM经常进行的操作
	获取元素
	对元素进行操作
	动态创建元素
	事件（什么时候做相应的操作）

	this的几种属性
	1、普通函数中的this-->windows
	2、构造函数中的this-->当前构造函数创建的对象
	3、方法中的this-->方法中的属性
	4、事件处理中的this-->事件源，谁调用该事件，this就指向谁

	非表单元素（只是展示，不与用户进行交互）div/span/img
	表单元素（可以与用户进行交互）href/title/id/src/claaName

	console.log();
	console.dir();

	console.log(box.innerText);  // 只获取文本，标签会被解析
	console.log(box.innerHTML);  // 如果有标签，也会打印出来
	box.innerText="<b>我爱你</b>";     ==><b>我爱你</b>
	box.innerHTML="<b>我爱你</b>";	   ==>我爱你

	Math.radom();  // 随机数[0,1)
	var randomIndex=parseInt(Math.random()*option.length);

BOM对象与DOM对象之间的转换
	dom-->bom	$(document.getElementById("aijquery"))
	bom-->dom	$("#aijquery").get(0);		$("#aijquery")[0];
## DOM中获取元素的方式:
	document.getElementById("id的值");	//根据id获取元素,一个
	document.getElementsByTagName("标签名");//根据标签的名字获取,多个
	document.getElementsByName("name属性");//根据name属性值获取,多个
	document.getElementsByClassName("类样式名");//根据类样式的名字,多个
	document.querySelector("div").innerHTML
## jQuery获取元素的方式:通过各种选择器来获取元素
	根据id来获取--->id选择器  ---->$("#id的值");一个
	根据标签的名字来获取---标签选择器--->$("标签的名字");多个
	根据类样式的名字获取--->类选择器--->$(".类样式的名字");多个
	.next();获取的是当前元素的下一个兄弟元素
	.nextAll();获取的是当前元素的后面的所有的兄弟元素
	.prev();获取的是当前元素的前一个兄弟元素
	.prevAll();获取的是当前元素的前面的所有的兄弟元素
	.siblings();获取的是当前元素的所有的兄弟元素(自己除外)
	标签+类样式的选择器获取元素
	$("li.cls").css("backgroundColor","yellow");		
	$("span,p,li,div").css("backgroundColor","yellow");多条件选择器获取
	$("#dv p").css("backgroundColor","red");   获取div中所有的p标签元素
	$("#dv>p").css("backgroundColor","red");获取的是div中直接的子元素
	$("#dv+p").css("backgroundColor","red");获取的是div后面第一个p标签
	$("#dv~p").css("backgroundColor","red"); div后面所有直接的兄弟元素p
	$("#dv *").css("backgroundColor","yellow");就是所有的元素
	$("#uu>li").mouseover(function () {};   根据层次选择器获取li  
	$("#uu>li:even").css("backgroundColor","yellow");   偶数的li
	$("#uu>li:odd").css("backgroundColor","red");    奇数的li 
	$("#uu>li:eq(4)").css("backgroundColor","red");ul中索引为4的li元素
	$("#uu>li:gt(4)").css("backgroundColor","red");索引大于4的li元素
	$("#uu>li:lt(4)").css("backgroundColor","red");索引小于4的li元素
	$(function () {
		$("ul>li").mouseenter(function () {
			$(this).css("backgroundColor","red").siblings().css("backgroundColor","");
		}).mouseleave(function () {
			$(this).css("backgroundColor","").siblings().css("backgroundColor","");
		}).click(function () {
			//链式编程代码
			//断链:对象调用方法,返回的不是当前的对象,再调用方法,调用不了,
			//解决断链--->恢复到断链之前的一个效果--修复断链
			//.end()方法恢复到断链之前的效果
			$(this).prevAll().css("backgroundColor","yellow").end().nextAll().css("backgroundColor","blue");
		});
	});
	$(this).siblings("li").children("ul").find("li").hide(500);
	// 设置元素样式的代码方式:链式编程
	$("ul>li").css("backgroundColor","yellow").css("fontSize","50px").css("fontFamily","全新硬笔行书简").css("color","blue");
	// 设置元素样式的代码方式:键值对
	$("ul>li").css({"backgroundColor":"yellow","fontSize":"50px","fontFamily":"全新硬笔行书简","color":"blue"});
	addClas添加样式的时候.多个类样式的名字中间用空格隔开
	$("#dv").addClass("cls cls2");
	var result=$("#dv").hasClass("cls");
	$("body").toggleClass("cls");    //自动切换类样式
## jQuery中常用的方法
	.val() 方法--->获取按钮的value属性的值
	.val("content"); 是设置按钮的value属性的值
	.html() 方法,设置标签中间显示其他标签及内容,类似于innerHTML 
	.html("content");  设置文字内容
	.text() 方法,设置标签中间显示的文本内容,类似于innerText
	.text("content"); 设置文字内容
	.css("属性","属性值");
	.css("属性","属性值").css("属性","属性值");  链式编程
	.css({"属性":"属性值","属性":"属性值"});  键值对
	addClass("类样式名字");添加一个类样式
	addClass("类样式名字1  类样式名字2");
	removeClass("类样式名字");移除类样式
	removeClass();移除的是当前元素中所有的类样式
	hasClass();判断当前元素是否应用了某个类样式
	toggleClass();切换元素的类样式的
	show()/hide()
	slideUp()/slideDown()	
	slideToggle()
	fadeIn()/fadeout()		
	fadeToggle()
	fadeTo(1000,0.3);   //一秒钟 透明度达到0.3
	$("#dv").animate({"width":"300px","height":"300px","left":"300px"},
		1000,function(){
			$("#dv").animate({"width":"50px","height":"30px","left":"800px","top":"300px","opacity":0.2},2000);
		}
	});



## DOM中创建元素:

	document.write("标签代码");缺陷:页面加载后创建,覆盖页面中原有内容
	innerHTML
	document.createElement("标签的名字")

## jQuery中创建元素的方式:

	$("标签的代码")
	对象.html("标签的代码");
	var aObj=$("<a href='http://www.baidu.com'>百度"+i+"</a>");
	$("#dv").append(aObj);   //把超链接追加到div中
	$("#dv").prepend(aObj);  //把元素插入到某个元素的前面
	$("#dv").after(aObj);//把元素添加到当前元素的后面(兄弟元素来添加)
	$("#dv").before(aObj);//把元素添加到当前元素的前面(兄弟元素来添加)
	var pObj= $("<p></p>");//创建p标签
	pObj.text("哈哈哈,我又变帅了");
	$("#dv").append(pObj);//把pObj对象主动的加到div中
	pObj.appendTo($("#dv"));
	$("#dv").html("<p>这是一个p标签</p>");
	$("#dv").html("");//清空元素中的内容
	$("#dv").empty();//清空元素中的内容
	$("#dv").remove();//移除元素自身---自杀
	var spanObj=$("#dv>span").clone();//克隆,复制了这个元素

## 元素绑定多个事件(推荐用on)

	bind()方法可以为元素同时绑定多个事件
	$("#btn").bind({"click":function(){
		alert("我被点了");
	},"mouseover":function(){
		$(this).css("backgroundColor","red");
	},"mouseout":function(){
		$(this).css("backgroundColor","");
	}});
	delegate():参数:3个
	要绑定事件的元素---p
	要绑定的事件的名字---click
	绑定事件的处理函数---匿名函数
	$("#dv").delegate("p","click",function () {
		alert("我被点了");
	});
	on（）
	三个参数:父级元素.on("事件类型","子级元素",事件处理函数)
	两个参数：父级元素.on(“事件类型”,事件处理函数)
	$("#dv").on("click","p",function () {
		alert("我被点了");
	});

## 解绑事件

	on <-->off  dalegate<-->undelegate  bind<-->unbind
	$(function () {
		//点击第一个按钮为div中p绑定点击事件
		$("#btn1").click(function () {
			$("#dv").delegate("p","click",function () {
				alert("我被点了");
			});
		});
		//点击第二个按钮为div中p解除绑定事件
		$("#btn2").click(function () {
			$("#dv").undelegate("p","click");//解绑
		});
	});

## 触发事件

	$("#btn1").click();
	$("#btn1").trigger("click");  //trigget()方法中需要写上触发事件的名字
	$("#btn1").triggerHandler("click");

## 浏览器默认事件

	$("#txt").focus();   //浏览器默认事件(光标在文本框中闪烁)
	$("#txt").trigger("focus");   //浏览器默认事件(光标在文本框中闪烁)
	$("#txt").triggerHandler("focus");   //不是浏览器默认事件（没有光标）

## offset cilent scroll
offsetHeight: 元素在垂直方向上占用的空间大小，以像素计。包括元素的高度、（可见的）水平滚动条的高度、上边框高度和下边框高度。
offsetWidth: 元素在水平方向上占用的空间大小，以像素计。包括元素的宽度、（可见的）垂直滚动条的宽度、左边框宽度和右边框宽度。
offsetLeft：元素的左外边框至包含元素的左内边框之间的像素距离。
offsetTop：元素的上外边框至包含元素的上内边框之间的像素距离。

clientWidth：元素内容区宽度加上左右内边距宽度。
clientHeight：元素内容区高度加上上下内边距高度。

scrollHeight：在没有滚动条的情况下，元素内容的总高度。
scrollWidth：在没有滚动条的情况下，元素内容的总宽度。
scrollLeft：被隐藏在内容区域左侧的像素数。通过设置这个属性可以改变元素的滚动位置。
scrollTop：被隐藏在内容区域上方的像素数。通过设置这个属性可以改变元素的滚动位置。

console.log($(".box1").get(0).offsetHeight);
console.log($(".box1")[0].offsetWidth);

## CS 架构
	在C/S结构的情况下，不同的服务需要安装不同的客户端软件，进而占用非常多的系统资源。

## bs 架构
  B/S（即Broswer、Server）解决了C/S所带来的不便，都可以通过浏览器来完成只要刷新网页即可，要但B/S也有一些不利，比如操作稳定性、流畅度等方面相对较弱。

## 客户端
	具有向服务器索取服务能力的终端，如比如 手机、电脑等，通过安装不同的客户端软件，可以获取不同的服务，
	以浏览器为宿主环境，结合 HTML、CSS、Javascript等技术，而进行的一系列开发，通常称之为前端开发。

## 服务端
	通俗的讲，能够提供某种服务的机器（计算机）称为服务器。
## 服务器类型
	1、按服务类型可分为：文件服务器、数据库服务器；
	2、按操作系统可分为：Linux服务器、Windows服务器等；
	3、按应用软件可分为 Apache服务器、Nginx 服务器、IIS服务器、Tomcat服务器、Node服务器等；
## 服务器软件
	使计算机具备提供某种服务能力的应用软件，称为服务器软件，通过安装相应的服务软件，然后进行配置后就可以使计算具备了提供某种服务的能力。
	1、文件服务器：Server-U、FileZilla、VsFTP等；
	2、数据库服务器：Oracle、MySQL、PostgreSQL、MSSQL等；
	3、邮件服务器：Postfix、Sendmail等；
	4、web服务器：Apache、Nginx、IIS、Tomcat、NodeJS等；
## Web服务器
	即网站服务器，主要提供文档(文本、图片、视频、音频)浏览服务，一般安装Apache、Nginx服务器软件。
	HTTP服务器可以结合某一编程语言处理业务逻辑，由此进行的开发，通常称之为服务端开发。
	常见的运行在服务端的编程语言包括 PHP、Jsp、Asp、Python、Ruby, go等。
## IP 地址
	所谓IP地址就是给每个连接在互联网上的主机分配的一个32位地址。
	查看本机IP地址 ping、ipconfig、ifconfig
	公网ip，局域网ip
## 域名
	由于IP地址基于数字，不方便记忆，于是便用域名来代替IP地址，域名是一个IP地址的“面具”
	查看域名对应的IP地址 ping、tracert。
## DNS服务
	DNS记录了 IP 地址和域名的映射（对应）关系；
	查找优先级 本机hosts文件、DNS服务器。
## 端口
	端口号是计算机与外界通讯交流的出口，每个端口对应不同的服务。
	查看端口占用情况 netstat -an。
	常见端口号 80、8080、3306、21、22。
## 搭建web服务器
	Windows (Linux) + Apache + Mysql + PHP，首字母组合
## 管理HTTP服务
##  配置根目录 
##  网站部署
##  配置虚拟主机
	1、开启虚拟主机辅配置，在httpd.conf 中找到,去掉前面的#号注释，开启虚拟主机配置
	2、配置虚拟主机，打开conf/extra/httpd-vhosts.conf 分别修改以下三项
		DocumentRoot "E:/www/example"
		ServerName "example.com "
		ServerAlias "www.example.com"
	3、修改DNS（hosts）文件 打开C:\Windows\System32\drivers\etc\hosts  目录是固定的
		注：修改hosts文件权限
	4、重启Apache
	5、浏览器访问www.example.com
## 静态资源 与动态资源
	静态资源：可以直接被浏览器解析的资源我们称为静态资源，比如html,javascript,css,video 等。
	动态资源:动态资源在服务器被解析，可以被转换为静态资源。 
	区别：如果我们客户端浏览器访问的是静态资源，那服务器接收到请求后，会直接将静态资源响应给客户端。
	如果客户端浏览器访问的是动态资源，那么服务器接收到请求后会将动态资源转换成静态资源，然后进行响应。

## ajax
	1、显示新的HTML内容而不再如整个页面
	2、提交表单而不用立即显示结果
	3、登录而不跳转到新的页面
	4、星际评价
	5、遍历数据库信息，加载更多而不刷新页面
	同步交互：客户端给服务器发送请求，服务器给客户端一个响应，响应回来的数据会把客户端的界面给覆盖。
	异步交互:客户端给服务器发送一个请求，服务器给客户端一个响应，响应回来的数据不会把原来的页面覆盖掉。
	ajax 的概念：ajax 就是实现页面 不刷新 ，可以直接获取服务器端数据。
	ajax 的原理：利用XMLHttpRequest 发送请求，接收请求的数据.
	ajax 的应用
## 利用XMLHttpRequest对象去进行交互，分为四步
	1:创建对象
	var xhr=new XMLHttpRequest();
	2:打开连接
	xhr.open("get","login.php?username="+zhangsan);
		1.打开方式（ get 或 post ）
		2.地址
		3.是否异步
			异步:非阻塞 前面的代码不会影响后面代码的执行
			同步:阻塞 前面的代码会影响后面代码的执行
	3:发送数据
	xhr.send(null);
	4:接收数据，只能通过异步的方式，就是只能通过回调函数的方式.
	//时刻监听这服务器端状态的改变. onreadystatechange 也是xhr 的一个属性.
	xhr.onreadystatechange=function(){
		//服务器数据响应成功之后会调用这个函数.
		//跟服务器进行交互，服务器会进行处理
		//在处理的过程当中会不断的给我一些状态.  0,1,2,3，4
		//每个状态代表的是不同的含义，readyState 属性去获取到，如果状态等于 4 代表响应完成
		readyState : ajax工作状态
		responseText : ajax请求返回的内容就被存放到这个属性下面
		on readystate change : 当readyState改变的时候触发
		status : 服务器状态，http状态码
		if(xhr.readyState==4){  //响应完成.
			//console.log("响应完成") 如果响应的是200 才代表响应成功
			//我们要获取到服务器端状态吗.
			if(xhr.status==200){
				//真正的处理.
				//响应完成的，响应是成功的.
				//接收服务器端返回的数据.responseText 用来接收服务器响应的数据的
				var data=xhr.responseText;
				document.querySelector("span").innerHTML=data;
			}
		}
	}
	get 交互与post 交互需要注意的细节:
	get 注意：请求的参数在地址栏当中，send 方法不能省略
	post 注意需要有一个特殊的请求头 Content-Type: application/x-www-form-urlencoded
	请求的参数写在send 里面
## 检测用户名是否已经存在
	<body>
		<input typt="text" />
		<div></div>
	</body>
	<script>
		document.querySelector("input[type=text]").onblur=function(){
			var username=document.getElementById("username").value;
			var xhr=new XMLHttpRequest();
			xhr.open("get","./api/checkUser.php?username="+username);
			xhr.send(null);
			xhr.onreadystatechange=function(){
				if(xhr.readyState==4 && xhr.status==200){
					var data=xhr.responseText;
					document.querySelector("div").innerHTML=data;
				}
			}
		}
	</script>
	<?php
		header("Content-Type:text/html;charset=utf-8);
		$user=$_GET["username"];
		$users=array("zhang","wang","li","zhao");
		if(in_array($user,$users)){
			echo "已存在";
		}else{
			echo "可以使用";
		}
	?>
## ajax get交互与post 交互
	get 交互请求的数据都在地址的后面，send() 方法不能省略
	post 方式提交需要设置特殊的请求头 Content-Type:application/form-data
## 新型数据格式-->便客户端方便解析服务器返回的复杂的数据结构
	xml，历史悠久的一个数据格式。早起的这种系统都是使用xml
	json，互联网的项目的数据交互都是采用json
	有一些大型的公司，它要对外提供接口，让别人去调用，它也要响应数据格式。一般他们都会支持两种数据格式.
## XML 格式数据  虽然可以描述和传输复杂数据，但是其解析过于复杂并且体积较大，所以实现开发已经很少使用了。
	XML是一种标记语言，很类似HTML，其宗旨是用来传输数据，具有自我描述性（固定的格式的数据）。软件的配置文件。 可扩展标记语言.
	1、必须有一个根元素，xml 也是由标签组成。开始标签，结束标签
	2、不可有空格、不可以数字或.开头、大小写敏感
	3、可以嵌套，不可交叉嵌套
	4、属性双引号（浏览器自动修正成双引号了）
	5、特殊符号要使用实体
	6、注释和HTML一样
## 服务端  服务器响应xml 格式的数据，
	设置一个响应头,告诉客户端，服务器返回的是一个xml 格式的文本。
	header("Content-Type:text/xml;charset=utf-8");
	输出XML格式的数据
	echo "";
## 客户端   接收XML格式的数据并解析
	xml 跟 html 的语法非常相似，解析html 的时使用dom 对象，然后调用dom 的api 去进行解析.
	先把xml 转换成html，就可以按照html 方式去进行解析。
## 将xml 数据的格式，转换成dom 对象
	1:服务器，必须设置一个响应头  Content-Type:text/xml;charset=utf-8
	2:客户端接收数据，接收普通文本  responseText，接收的是有格式的xml
## JSON 格式数据    轻量级的文本数据交换格式，独立于语言。
## 语法规则
	json 的数据格式是以键值对的方式进行存储,key=value,key=value
	数据在名称/值对中
	数据由逗号分隔(最后一个健/值对不能带逗号)
	花括号保存对象方括号保存数组
	使用双引号
## 怎么表示数据
	表示一条记录
		{
			"id":11,"username":"zml","loginName":"zhang","password":"111111"
		}
	表示多条记录(数组)
		[
			{
				"id":11,"username":"xiaoqin","loginName":"xiaoxuanfeng","password":"111111"
			},
			{
				"id":22,"username":"heixuanfeng","loginName":"heixuanfeng","password":"111111"
			}
		]
	表示复杂数据
		{
			response:{
						rows:[
							{
								"id":11,"username":"xiaoqin","loginName":"xiaoxuanfeng","password":"111111"
							},
							{
								"id":22,"username":"heixuanfeng","loginName":"heixuanfeng","password":"111111"
							}
						]
					},
			"status":200
		}
## json 格式数据使用
	服务器端发送json 格式的数据
	实际上在开发的过程当中，服务器返回的数据都是从数据库取出来的，取出来的可能是一条记录，也可能是多条记录，
	我们怎么把这些格式的数据响应到客户端，然后在客户端进行解析。
## 服务端：
	怎么将数据库的数据获取到转换成json 格式的数据，向客户端输出。
	header("Content-Type:text/json;charset=utf-8");
## 客户端：
	怎么接收到服务器端返回的数据并解析.		
	第一种解析方式:  eval();
	第二种解析方式:  JSON.parse();
	案例：异步去获取服务器的用户的数据
## ajax 封装
	封装的主要目的，一个页面可能发多次ajax 请求，每次请求的都是4步，创建对象，打开连接，发送数据，接收数据。
	调用一次，写一次这样的代码。所以，需要封装到一个方法里面去.在一个页面可能发送多次请求，每次请求的时候时候都需要调用这段代码.
## 交互分为四步 1:创建对象 2:打开连接 3:发送数据 4:接收数据，只能通过异步的方式，就是只能通过回调函数的方式.
	封装第一步，把相同的逻辑提炼到一个方法
## 封装的这个函数支持get 以及post 方式提交.
	function ajax(type,url,data,success){
		var xhr=new XMLHttpRequest();
		//进行一个处理，用户可能get 方式提交，也可能post方式提交.
		//要让type 的提交方式支持大小写
		type=type.toLocaleLowerCase();  //将一个字符串转换为小写.
		if(type=="get"){
			url=url+"?"+data;
			data=null;
		}
		xhr.open(type,url);
		//如果是post 方式提交，需要设置一个请求头
		if(type=="post"){
			xhr.setRequestHeader("Content-Type","application/x-www-form-urlencoded");
		}
		xhr.send(data);
		xhr.onreadystatechange=function(){
			if(xhr.readyState==4 && xhr.status==200){
				var data=xhr.responseText;
				//请求的数据完成以及成功的时候调用.
				success(data);
			}
		}
	}
## 传递参数太多为了方便维护，把参数封装在一个对象里面。
## 为了避免自己封装的函数跟其它的库不产生冲突，把封装的方法以及属性包装在一个函数里面。
## 一般都是以面向对象的方式去组织页面上面的代码
	// 将方法，以及属性包在一个对象里面.
	var $={
		ajax:function(obj){
			var xhr=new XMLHttpRequest();
			//进行一个处理，用户可能get 方式提交，也可能post方式提交.
			//要让type 的提交方式支持大小写
			obj.type=obj.type.toLocaleLowerCase();  //将一个字符串转换为小写.
			if(obj.type=="get"){
				obj.url=obj.url+"?"+obj.data;
				obj.data=null;
			}
			xhr.open(obj.type,obj.url);
			//如果是post 方式提交，需要设置一个请求头
			if(obj.type=="post"){
				xhr.setRequestHeader("Content-Type","application/x-www-form-urlencoded");
			}
			xhr.send(obj.data);
			xhr.onreadystatechange=function(){
				if(xhr.readyState==4 && xhr.status==200){
				var data=xhr.responseText;
				//请求的数据完成以及成功的时候调用.
				obj.success(data);
				}
			}
		}
	};
## 封装扩展
	var $={
	//新增的函数，函数的功能，将一个对象转换成字符串
	params:function(obj){
		//将对象的key 作为参数名，key 对应的值作为参数值。
		var str="";
		//username=zhangsan&age=11&sex=nan
		for(var key in obj){
			str+=key+"="+obj[key]+"&";
		}
		//组装的字符串多了一个&,截取之后返回一个新的字符串
		str=str.substr(0,str.length-1);
		return str;//出来是要发送到后台的数据，参数名，参数值.
	},
	ajax:function(obj){
		var xhr=new XMLHttpRequest();
		//新增功能1:处理，这个data 对应的值支持是一个对象
		//将 对象={username:"zhangsan",age:11,sex:"nan"}  转换成 字符串的格式  username=zhangsan&age=11&sex=nan
		//新增功能4：请求发送之前调用. 如果该函数return false ，组织改代码继续往下执行.
		var flag=obj.beforeSend();
		if(flag==false){
			return;
		}
		//对obj.data 的类型进行判断，如果是对象类型，才去进行处理.
		if(typeof obj.data=="object"){
			//在这里进行处理
			//提炼一个方法，参数是obj={} 出来的字符串username=zhangsan&age=11&sex=nan
			//this 现在指向到 $
			obj.data=this.params(obj.data);
		}
		// 如果是get 方式提交，参数在地址的后面
		if(obj.type.toLowerCase()=="get"){
			obj.url=obj.url+"?"+obj.data;
			obj.data=null;
		}
		xhr.open(obj.type,obj.url);
		// 处理post 我们需要给一个请求头
		if(obj.type.toLowerCase()=="post"){
			xhr.setRequestHeader("Content-Type","application/x-www-form-urlencoded");
		}
		xhr.send(obj.data);
		xhr.onreadystatechange=function(){
			if(xhr.readyState==4){  //响应完成
				if(xhr.status==200){ //响应成功
					var data=xhr.responseText;
					obj.success(data);
				}else{
					//失败的时候去调用error
					//新增功能2
					obj.error();
				}
				//新增功能3
				//请求完成的时候调用
				obj.complete();
				}
			}
		}
	}
## 完整封装
	var $={
		//新增的函数，函数的功能，将一个对象转换成字符串
		params:function(obj){
			//将对象的key 作为参数名，key 对应的值作为参数值。
			var str="";
			//username=zhangsan&age=11&sex=nan
			for(var key in obj){
				str+=key+"="+obj[key]+"&";
			}
			//组装的字符串多了一个&,截取之后返回一个新的字符串
			str=str.substr(0,str.length-1);
			return str;//出来是要发送到后台的数据，参数名，参数值.
		},
		ajax:function(obj){
			var xhr=new XMLHttpRequest();
			//新增功能1:我要处理，这个data 对应的值支持是一个对象
			//将 对象={username:"zhangsan",age:11,sex:"nan"}  转换成 字符串的格式  username=zhangsan&age=11&sex=nan
			//新增功能4：请求发送之前调用. 如果该函数return false ，我就组织改代码继续往下执行.
			//console.log(obj.beforeSend);
			if(obj.beforeSend){ //因为用户在调用的时候，可能没有传递,所以需要进行判断.
				var flag=obj.beforeSend();
				if(flag==false){
					return;
				}
			}
			//对obj.data 的类型进行判断，如果是对象类型，我才去进行处理.
			if(typeof obj.data=="object"){
				//在这里进行处理
				//提炼一个方法，参数是obj={} 出来的字符串username=zhangsan&age=11&sex=nan
				//this 现在指向到 $
				obj.data=this.params(obj.data);
			}
			//注意：如果是get 方式提交，参数在地址的后面
			if(obj.type.toLowerCase()=="get"){
				obj.url=obj.url+"?"+obj.data;
				obj.data=null;
			}
			xhr.open(obj.type,obj.url);
			//注意：处理post 我们需要给一个请求头
			if(obj.type.toLowerCase()=="post"){
				xhr.setRequestHeader("Content-Type","application/x-www-form-urlencoded");
			}
			xhr.send(obj.data);
			xhr.onreadystatechange=function(){
				if(xhr.readyState==4){  //响应完成
					if(xhr.status==200){ //响应成功
						var data=xhr.responseText;
						obj.success(data);
					}else{
						//失败的时候去调用error
						//新增功能2
						//等价于
						/* if(obj.error){
							obj.error();
						}*/
						obj.error && obj.error();
					}
					//新增功能3  请求完成的时候调用
					// if(obj.complete){
					//     obj.complete();
					// }
					obj.complete && obj.complete();
				}
			}
		}
	}



## php 编程
## php 入门
	文件以.php后缀结尾  
	<?php
		/** 这里是代码 **/ 
	?>
	注释    
		单行注释：    //注释内容
		多行注释：    /*多行注释*/
	变量
		$变量名=值;
		php中的变量必须参"$"开头，
		变量名只能包含字母、数字、下划线，只能以字母、下划线开头。
		unset(变量名);  // 删除变量
	预定义变量
		$_GET		用于接收前台表单使用get方式提交的数据
		$_POST		用于接收前台表单使用post方式提交的数据
		$_REQUEST	用于接收前台表单使用get或post方式提交的数据
		$_SERVER	记录了服务器端与客户端的相关信息
		$_COOKIE	一种会话技术
		$_SESSION	一种会话技术
		$_FILES		用于记录用户上传的文件信息
		$GLOBAL	    用于记录全局变量
	程序语言就是对内存进行操作的
		①、栈区 保存的是变量名(术语称之为引用)。特点：对于cpu来说，读写速度是最快的
		②、数据段 存储的是简单的数据，例如：整形、浮点型、布尔值
		③、堆区 存储的“复杂”的数据，数组、对象
		④、代码段 存储的是源代码的对应的机器指令。(人能看懂的计算机是看不懂的，必须经过转换)
		⑤、输出缓存 只要遇到输出命令，例如:echo 、print、print_r、var_dump，这些指令都会将所要输出数据放在输出缓存中。
	php嵌入到HTML的执行过程
		当php功能模块在处理一个php文件时，它只关心php代码(使用PHP标签包含的代码)。对于非php代码，它会原样输出。
	php中变量的传值方式
		在Php中变量有两种传值方式：
			①、赋值传值 使用一个变量a为另一个变量b赋值时，传递的是变量a的值，这种赋值方式就是赋值传值
			②、引用传值 使用一个变量a为另一个变量b赋值时，传递的是变量a的地址，这种赋值方式就是引用传值
	常量
		define('常量名',值);
		const 常量名=值;
		常量一旦定义就不允许更改
		常量的值只能是基本数据类型(标量数据类型)
		常量是默认区分大小写，一般常量在命名时，我们会使用全大写的形式
		define  VS  const
		define语法可以在分支结构中定义常量，const不允许的。
		define定义的常量可以自定义是否区分大小写。
	魔术常量  php中又定义了一组魔术常量。
		__FILE__		用于获取前文件名完整路径及文件名
		__DIR__			用于获取当前文件的路径
		__LINE__		用于获取当前行号
		__FUNCTION__	用于获取当前函数的函数名
		__METHOD__		用于获取当前方法的方法名
		__CLASS__		用于获取当前类的类名
		__NAMESPACE__	用于获取当前空间的空间名
	PHP的数据类型
    	PHP数据类型分为三大类八小类
			①、标量(scalar)数据类型
				int(整型) float(浮点类型) boolean (布尔类型) string (字符串)
			②、复合数据类型
				array(数组)  索引数组、关联数组、多维数组
					遍历关联数组
					<?php
						$age=array("Bill"=>"63","Steve"=>"56","Elon"=>"47");
						foreach($age as $x=>$x_value) {
							echo "Key=" . $x . ", Value=" . $x_value;
							echo "<br>";
						}
					?>
				object(对象)
			③、特殊数据类型
				null(null) resource(资源类型)
		整数(Int)类型 线性的整数
			十进制 $v = 255;
			八进制 以0开头，并且不能有超过7的数字
			十六进制 以0x开头，包含0-9   a-f
	    浮点(float)类型 带有小数点的数就是浮点类型。
			小数有两种表示方式： 普通方式：
			科学计数法： 示例：
		字符串(String)类型 字符串就是使用单引号或双引号括起来的0个或多个字符。
			使用单引号定义的字符串 能够被转义的字符有 \\    \’
				单引号定义的字符串中的变量不能解析其值。
			使用双引号定义的字符串 能够被转义的字符有 \”   \t   \r  \n  \\   \$
				双引号定义的字符串中的变量的值可以被解析。
		转义符：\  用于将程序语言所赋予的某些字符的特殊功能转义掉。 输出不可见的符。 
			转义符能够转义的字符：
			\' (单引号) \" (双引号) \t (tab符) \r (回车符) \n (换行符) \\ (\) \$ ($)
		布尔(Boolean)类型 布尔类型只有两个值：
			true(成立) false(不成立)
		数组(Array)类型
			索引数组 数组元素的下标是数值，这样的数组就是索引数组
			关联数组 数组元素的下标是字符串，这样的数组就是关联数组。
		数据类型的转换
			(integer)变量		将其他数据类型强制转换为整型
			(float)变量			将其他数据类型强制转换为浮点型
			(array)变量			将其他数据类型强制转换为数组
			(object)变量			将其他数据类型强制转换为对象
			(string)变量			将其他数据类型强制转换为字符串
			(boolean)变量		将其他数据类型强制转换为布尔值
		数据及类型的判断 判断函数的格式的规律：
			is_int(v);
			is_string(v);
			is_bool(v);
			is_float(v);
			is_scalar(v)		判断变量的类型是否是int、string、bool、float
			is_array(v)
			is_object(v)
			is_resource(v)
			is_null(v);
			isset(v)			用于判断变量是否有设置值(判断变量的值是否为null值)。

### 字符串  
	trim()  chop()   ltrim()   rtrim()	trim() 函数移除字符串两侧的空白字符或其他预定义字符。

### 数组
## 数字索引数组
索引的默认值是从0开始的，当然也可以改变它
$arr = array('zhang','wang','li','zhao');
$arr = ['zhang','wang','li','zhao'];
array() 实际上是一个语言结构，而不是一个函数
$arr = range(1,10);
$arr = range(1,10,2);
$arr = range('a','z');
访问数组   $arr[0]   
遍历数组
for($i = 0 ; $i < 9 ; $i++){
	echo $arr[$i].'';
}

foreach($arr as $value){
	echo $value.'';
}

PHP 中 implode() 和 explode()

1， implode()函数返回由数组元素组合成的字符串，
	函数语法：string implode(separator,array),separator参数可选，规定数组元素之间放置的内容，默认是空字符串；array参数表示要组合为字符串的数组。

	<?php
		$arr = array('Hello','World!','I','love','Shanghai!');
		echo implode(" ",$arr);
	?>
	-->> Hello World! I love Shanghai!

2，explode()函数返回有字符串组成的数组，这些字符串都是另一个字符串被字符串 delimiter 作为边界点分割出来的。
	函数语法：array explode(string $delimiter,string $string),$delimiter表示边界上的分割字符；$string表示输入的字符串。

	<?php
		$data = "foo:*:1023:1000::/home/foo:/bin/sh";
		list($user, $pass, $uid, $gid, $gecos, $home, $shell) = explode(":", $data);
		echo $user; // foo
		echo $pass; // *
	?>
	-->> foo 2013

## 非数字索引数组
## 数组操作符
## 多维数组
## 数组排序
## 数组函数
### 进制
1、相关概念
数码：某一种进制中所出现的数字
基数：某一种进制中数码的个数(逢几进一)
位权：用于衡量某一种进制中数码所在的位置的大小的值。


2、计算机常用进制
①、十进制
数码：0 至 9
基数：10
位权： 

		(12345)10
按权展开式：1*104	+		2*103	+  3*102	+	4*101	+	5*100
10000        1000       100       10         1

②、八进制
数码：0  至 7
基数：8
位权：
		(12345)8
按权展开式：1*84	+		2*83	+  3*82	+	4*81	+	5*80
4096        512       64       8         1



③、十六进制
数码：0 至 9    a  至 f			a(十进制中的10)		f(十进制中的15)
基数：16
位权：
(12345)16
按权展开式：1*164	+		2*163	+  3*162	+	4*161	+	5*160
       			256       16         1
④、二进制
数码：0、1
基数：2
位权：
(11111)2
按权展开式：1*24	+		1*23	+  1*22	+	1*21	+	1*20
16         8			4        2        1


2、进制转换（了解）
	任何一种进制按权展开最终的结果都是十进制的值。
	所谓的按权展开就是，某一种进制中，各个位上的数码与当前位的位权的乘积之和。就是按权那个
①、二进制转换为十进制：
8421BCD码
位	位7	位6	位5	位4	位3	位2	位1	位0
权	128	64	32	16	8	4	2	1
二进制			1	0	1	1	0	1
二进制转换为十进制就是将1位对应的权相加即可得到对应的十进制数。



二、运算符
1、赋值运算符
=
运算规则：
	将赋值号右边的值赋值给左边的变量。左边必须是变量不能是式子。
 

2、算术运算符
+、-、*、/、%
%		取模(取余)
运算规则：求两个数相除，除不尽的部分。
 

在实际开发中，我们经常使用%运算判断奇偶数。

3、自操作运算符
++ 自增、--自减
自增运算符
	前自增	规则：先对变量的值自增1，再使用变量的新值参与式子的运算。
	后自增 规则：先使用变量的原值参与式子的运算，再对变量的值进行加1
示例：前自增
 
示例：后自增
 
 
说明：
	前++是先更改内存中变量的值，再将新值读取到这个式子中。
	后++是先取内存中的这个变量的值，放在式子中，再对变量的值加1

自减运算符
	前自减	规则：先对变量的值自减1，再使用变量的新值参与式子的运算。
	后自减 规则：先使用变量的原值参与式子的运算，再对变量的值进行减1

	$i+=2		等效于 $i=$i+2;
	$i-=2		等效于 $i=$i-2;
	$i*=2		等效于 $i=$i*2;
	$i/=2		等效于 $i=$i/2;
	$i%=2		等效于 $i=$i%2;

4、字符串运算符
.		对字符串进行拼接
.=		对字符串进行拼接
示例：
 
注意：
 


5、比较运算符
>、<、>=、<=、==、!=、===、!==
前提：
	与变量相关的有两部分：其一是值，其二是类型。
==			用于判断两个数的值是否相等
===			同时判断变量的值与类型是否相同，如果相同返回true，
示例：
 
!==		判断两个变量的值或类型至少有一方面不相同
 
提示：
	比较运算符得到的最终结果boolean类型的值

6、逻辑运算符
&&、||、!、and、or
&&		逻辑与
	运算规则：
真值运算规则：参与运算的两个操作数，如果同时为true或能转换为true，那么最终的结果就是true
假值运算规则：参与运算的两个操作数，只要有一个为false或能转换为false，那么最终的结果就是false
示例：
 

逻辑与短路：
 

||		逻辑或
运算规则：
	真值运算规则：参与运算的两个操作数，只要有一个为true或能转换为true，那么最终的结果就为true
	假值运算规则：参与运算的两个操作数，全部为false或能够转换为false，那么最终的结果才是false
示例：
 

逻辑或短路：
 

!		逻辑非
运算规则：对操作数据进行取反。
 

and		逻辑与
	运算规则与&&运算规则相同，唯一区别是&&的优先级高于=，而and的优先级是低于=
 

or		逻辑或
	运算规则与||运算规则相同，唯一的区别是||的优先级高于=，而or的优先级是低于=
 

运算符的优先级：
	在一个式子中可能会出现多种运算符，但运算符之间会有优先级。
	口诀：
	单、算、关、逻、条、赋、逗

7、条件运算符
三元运算符
语法：
	表达式?表达式A:表达式B;
运算规则：
	先计算表达式是否成立，如果成立取表达式A的值，如果不成立取表达式B的值。
	就是算简单的分支语句
示例：
 

扩展：了解
语法：
	变量?:表达式B
运算规则：
	如果变量能转换为true，那么就取变量，否则取表达式B。
 

8、错误控制运算符
①、错误抑制符
@		错误抑制符
作用是不显示错误信息。
 

②、php.ini中隐藏错误
 
说明：
	此种配置影响是全局。所有的使用此份php的配置文件的站点都会受此影响。
③、脚本级的错误控制
	脚本级的错误控制仅限于当前的Php脚本文件。
	ini_set()		主要用于在Php脚本中来设置php.ini中的配置项
语法：
	ini_set(配置项名,值);
示例：
 

	ini_get(配置项名)	主要是用于获取php.ini配置文件中的配置项的值
示例：
 


9、位运算符(了解)
位运算都是对一个数的二进制形式进行运算。
8421BCD码
位	位7	位6	位5	位4	位3	位2	位1	位0
权	128	64	32	16	8	4	2	1
二进制	1		1		1	0	1	0

|	按位或
运算规则：
参与运算的两个操作数的二进制形式对应的位进行与运算，如果对应的位只要有1个为1那么最终的结果位就1，如果都为0，最终结果位为0.
10 || 20			true | true		true
 

&	按位与
运算规则：
	参与运算的两个操作数的二进制形式对应的位，全部为1，最终的结果位为1，不是为0
示例：
 

^	按位异或
运算规则：
	参与运算的两个操作数的二进制形式对应的位，如果相同为0，不同为1
示例：
 
主要是用于记录同点。
扩展：
	 


~	按位非(单目运算符)
运算规则：
	对一个操作数的二进制形式中的每一位进行取反。

<<	左移
运算规则：
	对二进制数据整体向左移指定的位数。左侧移出要被忽略，右侧补0
 
左移，可以快速对一个数加位。

>>	右移
运算规则：
	对二进制数据整体向右移指定的位数。右侧移出要被忽略，左侧补0

示例：
 



三、原码、反码、补码(了解)
原码：
就是带有正负号的二进制数。
在计算机内所有的信息的表示都是使用0与1表示的，正负号与不例外。
人们规定，如果是正数，在最高位使用0表示+；如果是负数在最高位使用1表示-

反码：
	正数的反码与原码相同
	负数的反码，最高位的符号位不变，其余位取反。

补码：
	正数的补码与原码相同
	负数的补码是在反码的基础上加1
示例：
 
提示：
	以上只是在内存中的一个表现形式，最终在显示时还要转换为十进制数。
	对于正数，原码 到 反码 到 补码 没有任何的变动，所以找二进制对应的十进制数即可。
	对于负数，先由补码反推出反码，再由反码反推出原码，再将原码转换为十进制
 


四、进制转换函数
dec		decimal		十进制
bin		binary		二进制
oct		octet		八进制
hex		hex			十六进制
decbin()		十进制转换为二进制
dechex()		十进制转换为十六进制
decoct() 	十进制转换为八进制
 

五、php的输出语法
echo		
	只能输出标量数据类型，对于任何数据都要转换为字符串输出
示例：
 

print()
	只能输出标量数据类型，对于任何数据都要转换为字符串输出
示例：
 
echo 与print的区别：
echo没有返回值，print有返回值。

print_r()
可以输出标量，及复合数据类型。
示例：
 

var_dump();
	主要是用于程序员进行代码调试，可以输出十分详细的信息。并不是为了输出信息给用户。
 

sprintf();
用于格式化输出。
语法：
	sprint(格式化字符串,变量1,变量2,….)
说明：
	格式化占位符有
	%b			二进制
	%d			十进制
	%o			八进制
	%f			浮点
	%x			十六进制
示例：
 

六、php.exe文件
1、php内置的web服务器
php.exe  -S  locahost:端口号
 
 
提示：
	创建了内置的web服务器后，也需要使用浏览器访问php文件。


2、php_cli
	php的命令行模式
 

php –m
	查看php所加载的功能模块
 
php --ini
 

php –f 文件的名
 

php –r  “一行Php命令”
 

一、流程控制
计算机中的流程控制可分为三种：
顺序结构
	程序自上而下的一个执行过程。

分支结构
	根据某一条件将程序转向不同的分支处执行。

循环
	计算机最大的特点计算机速度快，计算机主要用于解决重复性的问题。

二、分支结构
1、if分支
①、单分支
语法：
	if(表达式){
		//语句体
}
说明：
	当表达式成功时，执行语句，如果不成功直接结束if结构，继续其后的语句执行。
 

②、双分支
语法：
	if(表达式A){
		语句体A 
}else if(表达式Ｂ){
	语句体B
}
说明：
	当表达式A成功时，执行语句体A，如果不成立来判断表达式B，如果表达式B执行语句体B
	当任何一个语句体执行结束后，不再会去进行其他表达式的判断。
示例：
 

③、多分支
语法：
	if(表达式A){
		语句体A 
}else if(表达式B){
	语句体B
}else if(表达式C){
	语句体C
}else{
	缺省语句体
}
说明：
	自上而下的判断各个表达式，当某个表达式成立时，执行相应的语句体
	语句体执行结束后，不会再判断其他的表达式。
	当所有的表达式都不成立，执行缺省语句体。
 
 

2、switch结构
	当一个问题需要判断的条件比较多时，Php又提供了一个switch分支结构。
语法：
    $day = 7;
    switch ($day) {
        case 1:
            echo '星期一';
            break;
        case 2:
            echo '星期二';
            break;
        case 3:
            echo '星期三';
            break;
        case 4:
            echo '星期四';
            break;
        case 5:
            echo '星期五';
            break;
        case 6:
            echo '星期六';
            break;
        case 7:
            echo '星期日';
            break;
        default:
            echo '数据有误';    
    }
说明：
	根据switch后的变量与case后的值的匹配情况，将程序转向不同的语句体执行。
	break可以省略。
	当一个语句体执行结束后，如果没有遇到break，则会执行其后的语句体，不会判断其后case的值。
示例：
 
if与switch的区别：
	if结构的条件可以表示一个范围。
	switch结构主要用于表示一个具体的值。

三、循环结构
1、for循环
循环结构主要是用于解决重复性的问题。
语法：
	for(循环控制变量初始化;表达式;循环控制变量的更改){
		//循环体
}
说明：
	循环控制变量初始化;表达式;循环控制变量的更改   循环3要素。
	a、首先执行循环控制变量初始化，此步仅执行1次。
	b、判断表达式是否成立，如果不成立直接结束循环体，继续其后的语句执行。
	c、如果成立，执行循环体。
	d、循环体执行结束后，执行循环控制变量的更改，
	e、往复执b、c、d，直到循环控制变量的值主表达式不成立时，结束循环结构。

对于for循环结构，要求大家能够作到以下几点：
	能够使用for循环，模拟任意次数的循环。
	能够使用循环控制变量来模拟数据或规则
循环嵌套：
 
提示：
	双层循环的嵌套主要解决具有行列特性的问题。

使用程序语言解决问题的思路：
	首先要判断使用何种流程控制。
	再将问题中的条件转换为计算机能够表达的式子。
示例：
 

课堂案例：
	百钱百鸡，100文钱买100只鸡，公鸡5文1只，母鸡3文1只，小鸡1文3只。
穷举法：
 

2、while循环
语法：
	while(表达式){
		//循环体
}
说明：
	只要是循环必须有3要素组成。但是while循环的语句结构中仅出现了表达式。
	另外两个要素需要自己设计。
	首先判断表达式是否成立？
	不成立，直接结束循环结构，继续其后的语句执行。
	成立，执行循环体，循环体执行结束后，再来判断表达式。循环往复的执行。直接到表达式不成立。
示例：
 

for与while的区别
	对于for循环结构，主要用于循环次数已知或根据某一条件可以确定。
	while用于循环次数未知的循环。


3、do..while
语法：
	do{
		//循环体
}while(表达式)
说明：
	首先执行循环体
	循环体执行结束后，判断表达式是否成立，
	如果不成立，直接结束循环结构，继续其后的语句执行，
	如果成立，再执行循环体。往复的执行，直到表达式不成立。
示例：
 

4、循环的结束与退出
①、continue
语法：
	continue 【n】;
说明：
	n的取值是一个整数，如果省略默认是1，
	n主要是用在循环嵌套的情况下。
	结束当前循环结构的本次循环，继续上n层循环结构的下一次循环。
示例：
 
 
②、break
语法：
	break 【n】;
说明：
	n的取值是一个整数，如果省略默认是1，
	n主要是用在循环嵌套的情况下。
	直接结束上n循环循环结构
示例：
 


四、流程控制语句的标签语法
php在将php代码嵌入到html文档时，又提供了一种标签语法。
 
①、if标签语法：
标准语法：
<?php if(...):?>

<?php endif?>
简化语法：
<?php if(...){?>

<?php }?>

②、for标签语法
标准语法：
<?php for():?>

<?php endfor?>
简化语法：
<?php for(){?>

<?php }?>

③、while的标签语法
标准语法：
<?php while():?>

<?php endwhile?>
简化语法
<?php while(){?>

<?php }?>

五、文件载入
### 代码中用与函数编写
代码重用、使用require（）和include（）函数、函数介绍、函数定义、使用参数、理解作用域、返回值、参数的引用调用和值调用、实现递归
### 代码重用
通过代码重用更加轻松地编写一致性、可靠性、可维护性更高的代码
通过重复使用代码来避免编写新的代码
可以降低成本、增加代码的可靠性并提高他们的一致性
成本：在一个软件的生命周期的内，相当多的时间是用在维护、修改、测试和文档记录上，而不是最初花在编程上的时间
可靠性：使用现成的代码通常比新鲜绿色的代码更可靠
一致性：系统的外部接口应该是一致的，其中包括用户接口和系统的外部接口

使用require（）和include（）函数，可以将一个文件（PHP语句、文本、HTML标记、PHP函数或者PHP类）载入到PHP脚本
require("php文件地址（）一般为相对地址");
php语句放在HTML文件中时，他们是不会被处理的
PHP通常用来解析扩展名被定义成 .php 的文件（在web服务器配置文件中可能不是这样的），但是，如果通过require（）语句载入这个html文件，文件内的任意PHP命令都会被处理
如果扩展名为一些非标准扩展名的文件保存在web文档树中，而且用户可以在浏览器中直接载入他们，用户可以以普通文本形式查看源代码，包括任何密码，因此，将被包含文件保存在文档树之外，或者只用标准的文件扩展名是非常重要的

<?phprequire("header.inc");?>
Here is the content for this page
<?phprequire("footer.inc");?>
<!--
	<script>
		$(".header").load("./components/header.html");
		$(".content").load("./components/content.html");
		$(".footer").load("./components/footer.html");
	</script>
-->

include()语句和require()语句几乎是等价的
当这两个函数掉用失败后，require（）将给出一个致命的错误，而include（）只是给出一个警告
两者都有变体函数，分别为require_once()和inxlude_once()  确保被调用文件只被调用一次

1、介绍
	在实际开发过程中，经常会在一个php文件中引入其他的文件。
	被引入的文件可以是html也可以是php文件。

2、语法
①、require
	require(文件名)
	require_once(文件名)
②、include
	include(文件名)
	include_once(文件名)
示例：
 

在引用文件时，主要有两种使用目的：
当前文件(php)有数据，想在被引用的文件(html)中显示。
 
在当前文件(php)中想使用，另一个文件(php)中的功能性代码:
 

3、引入路径的问题
在实现项目中，对于html文件，我是不允许用户直接请求，而是指向一个php文件，让php文件来引处这个html文件。
当一个php文件引入一个html文档时，html文件本身也会引入一些其他的文件，如：图片文件、css文件、js文件。这时会发生路径更改的问题。路径要以当前php文件所在的路径为起点。
 
 

4、include与require区别
include	在引入文件时，如果被引入的文件不存在则会报错，但程序还会继续向下执行。
require在引入文件时，如果被引入的文件不存在，则会上断程序的执行。

经验法则：
	require一般用于引入php文件。因为php里面一般书写的是功能性的代码。
	include一般用于引入html文档。

include、require  VS  include_conce、require_once的区别
include_once、require_once每次在引入文件时，都会检查所要引入的文件之前有没有被引入过，如果有引入过就不会再引入。
include、require没有这样的检查过程。

5、__DIR__\__FILE__
__FILE__		用于获取文件所在的完整文件名。
__DIR__			用于获取文件所在的路径。
__FILE__与__DIR__并不会被引入后所更改。永远代码__FILE__与__DIR__所在的文件的文件名与文件夹名。


六、错误处理(了解)
1、错误的分类
	①、编译错误
		在编译的过程中发生的错误就编译错误，编码错误是最容易解决的。很多是由于书写错误。
		
	②、执行错误
		在编译通过后，在执行阶段发生的错误。此种错误一旦发生，会根据错误的等级，来决定是否中断程序的执行。
		
	③、逻辑错误
		由于程序的逻辑不严谨，而产生的错误。此种错误是最难排查的。程序可以正常执行，但最终的结果并不是我们所期望的。

2、错误代码
	在php的错误处理机制中，每一种错误都使用了一个错误标识，错误标识是常量的形式存在。
	①、获取错误代码
 
②、系统错误
E_ERROR			致命错误，一旦发生就会中断程序的执行
E_WRRING			警告错误，一旦发生并不会中断程序的执行，
E_NOTICE			提示错误，一旦发生并不会中断程序的执行，
E_PARSE				编译错误，一旦发生就会中断程序的执行

③、自定义错误
E_USER_ERROR		用户级的致命错误，一旦发生就会中断程序的执行
E_USER_WRRING		用户级的警告错误，一旦发生并不会中断程序的执行，
E_USER_NOTICE		用户级的提示错误，一旦发生并不会中断程序的执行，

④、所有的错误
E_ALL

3、错误的触发
①、系统错误的触发
	程序员无法干涉系统错误的触发，系统错误由php自已检测并触发的。
 
②、自定义的错误
trigger_error();
语法：
	trigger_error(msg,type);
说明：
	msg		错误描述信息
	type	自定义错误的代码(E_USER_ERROR、E_USER_WARNING、E_USER_NOTICE)
示例：
 
 
提示：
	使用错误处理机制的好处是，可以将错误记录起来。默认会被记录到apache的/logs/error.log文件中。

4、错误的控制设置
php错误控制可以在php.ini中进行。我们可以控制错误是否显示，还可以控制显示哪一类的错误。
①、控制是否显示错误
	display_errors=on		显示错误
	display_erros =off		关闭错误的显示

②、控制显示哪一类错误
	error_reporting = 
 


5、错误的日志文件的设置
我们还可以控制是否记录错误，以及错误日志的记录位置。
①、是否记录记录
log_errors=on		记录错误
log_errors=off		不记录错误

②、错误记录的位置
如果没有设置error_log默认是记录到apache的错误日志中\logs\error.log
error_log=syslog		会记录到操作系统的日志中
error_log=文件名	记录到自定义的位置
 
一、函数初步
1、基本概念
	函数是模块化程序的产物。在实际开发过程中，我们会将一个项目划分为各个大的功能模块。同将大的功能模块发为小的功能。
	再使用函数将这个最小的功能(一个动作)实现。
	从代码上看，函数就是使用{}，将完成某一功能的代码括起来(封装)，再使用function 关键字，
	为这段代码设置一个名子，这个名子就是函数名，函数名后必须有()，这个()表示函数只能被调用。

2、声明语法
	function function_name(形参列表){
		函数体
		【return 值】  // 可选
	}

3、调用语法
	function_name(实参列表);

4、函数名
	php中函数名是不区分大小写。函数名的命名规则与变量的命名规则相同。只能包含字母、数字、下划线。而且必须以字母或者下划线开头。


5、可变函数
	如果$a的值是另一个变量的名，那么可以使用$$a来访问另一个变量的值。
	如果$f变量的值是另一个函数名，那么可以使用这个变量来访问函数

6、函数体
	完成某一功能代码段

7、return语句
	在我们使用函数完成一些功能时，有时会将函数计算的数据，传递出来。此时可以使用return。

提示：
	程序是用于处理数据，函数所处理的数据有两个方向：
其一，从外到内，使用实参与形参。
其二，从内到外，使用return 
函数内部可以有多个return，只要遇到一个return就会中断函数的执行。
函数内也可省略return语句。

8、匿名函数
	没有名子的函数就是匿名函数(anonymous function)，也称之为闭包函数(closure)。
	提示：
	JS中的函数可以自调用，但是PHP中的函数没有办法自调用。
	php中的匿名函数，可以赋值给一个变量，还可以用于某个函数的参数。
	示例：将匿名函数赋值给变量，通过这个变量可以调用匿名函数。
 
9、回调函数callback：
	我们定义一个函数很多的时候是为了自己调用。
	但在开发过过程中，我们在别人的函数，或系统函数时。这个函数需要参数，而有些参数要求你传递的一个函数。作为参数传递的函数就是回调函数。

二、函数的参数
1、形参
	函数定义时的参数就是形参
	形参是被动的接收数据。
	形参只对内存有效，对于外部是不可见。

2、实参
	函数调用时的参数就是实参
	主动向函数内部传递实际的数据。

3、形参的默认值
	php中在定义函数时可以为形参赋值一个值，这个值就是形参的默认值。
	在调用函数时，如没有为具有默认值的形参传递数据，那么形参使用的是默认值，
	如果有为具有默认值的形参传递数据，那么这个形参使用实际传递过来的数据。
	一般具有默认值的形参位于，形参列表的最后。

4、形参的引用传值
	php中函数的实参与形参之间也是一种赋值方法，默认是	
	PHP中可以在形参前加&符号，将实参与形参之间默认的赋值传值，更改为引用传值。

5、伪类型(函数)
	PHP语言本身提供了8种数据类型。但是在使用手册中我们会遇到另外几中：
	mixed		表示类型不确定
	callback		表示函数
	scalar		如果是int、float、string、bool

6、相关函数(系统函数)
	func_get_args();
		用于获取实参，并以数组的形式返回。
	func_get_arg(ind);
		用于获取ind下标指定的实参
	func_num_args();
		用于获取实参的个数。

	…$变量名		用于将实参以数组元素的形式保存在这个变量中。

7、函数运行的内存原理
 

三、作用域
	在PHP中函数是用于封装某一功能的代码段，函数在对代码进行封装会有一些影响。
PHP中分两种作用域：全局作用域，局部作用域。
1、全局作用域与全局变量
	在函数外部的定义的变量，其作用域 就是全局作用域，变量就是全局变量。
示例：
 

2、局部作用域与局部变量
	在函数内部定义的变量，其作用域就是局部作用域，这个变量就是局部变量。
示例：
 

提示：
	默认php中有很”清晰”的作用域，外部只能访问外部的，内部只能访问内部。

3、global关键字
	虽然php默认作用很清晰，但是有时确定会外部访问内部或内部访问外部。如何解决？
①、通过参数的传址方式
在形参前使用&，可以达到内部访问外部
 

②、$GLOBALS
$_GET\$_POST….$GLBOALS，超全局变量
 
示例：
 
提示：
	以上两种变通的方式都只是实现了内部访问外部，如果我即想内部访问外部，外部也同时可以访问内部。

③、global关键字
语法:
	global 变量名;
说明：
	在函数内部建立一个与函数外部同名的变量的引用。如果外部有这样的同名变量，会在外部创建一个同名的变量。
 


4、常量的作用域
	常量没有作用域限制，一个脚本中的常量，在任何的位置都可以访问。

5、预定义变量(超全局变量)
	超全局变量也不受作用域的限制。


四、变量的生命周期
1、作用域与生命周期
	作用域	表示的是一个变量的作用空间范围。
	生命周期 表示的是一个变量的作用时间范围。

2、全局变量的生命周期
	全局变量 生命周期是从脚本执行开始到脚本执行结束。


3、局部变量的生命周期 
	局部变量 生命周期是从函数执行开始，到函数执行结束。


五、 静态变量
1、定义
在函数内部使用static声明的变量，就是静态变量。
示例：
 

2、原理
	静态变量在函数多次被调用时，只会被初始化一次，并且静态变量的值并不会随着函数执行后空间的销毁而被销毁。
	在函数下一次调用时，仍然可以访问其值。
 
提示：
	静态变量的使用场景，如果想在同一个函数多次调用时，共享一份数据。那么就使用静态变量。


六、系统函数
date_default_timezone_set("Asia/Shanghai");
$time = time();
echo (date("Y-m-d H:i:s",$time));
header('Content-Type:text/html;charset=uftf8');
1、日期时间函数
①、time()
说明：
	用于获取当前时间的时间戳。单位是秒。时间戳就是从时间原点至现在的一个秒数。
	时间原点，计算机中规定从1970年1月1日0时0分0秒那一时刻为时间原点。
 
②、microtime();
 

③、date()
语法：
	date(format【,time】);
说明：
用于格式化时间信息。
	
	time表示所要格式化的时间戳，如果省略表示对当前时间进行格式化。
	format用于格式化时间的字符串
	Y		表示4位的年份
	m		月份，有前导0
	d		表示，日期
	H		表示24小时机制的小时数
	i		表示分钟数
	s		表示秒数

④、mktime()
语法：
	mktime(时,分,秒,月,日,年);
说明：
	用于获取指定时间的一个时间戳。
 
⑤、strtotime()
语法：
	strtotime(string)
说明：
	将一个以字符的形式描述的时间信息转换为时间戳。

七、递归：函数调用函数本身，这些函数特别应用于浏览动态数据结构，例如链表(linked link)和树(tree)。
	递归解决问题的特点：完成一个需求有多个步骤，但完成每一步所实现的代码是十分相似的，只有函数所传递的参数不同而已。
	递归可以永凯取代循环，因为二者都是重复做一些事情。递归函数比循环慢而且要占用更多的内存，所以应该尽可能多用些循环。


fibonacci数列

reset() 函数将内部指针指向数组中的第一个元素，并输出。
current() - 返回数组中的当前元素的值
end() - 将内部指针指向数组中的最后一个元素，并输出
next() - 将内部指针指向数组中的下一个元素，并输出
prev() - 将内部指针指向数组中的上一个元素，并输出
each() - 返回当前元素的键名和键值，并将内部指针向前移动

#### 代码重用与代码编写  require include global & return
require()  include()
二者唯一的区别在于 语句执行失败后，require() 将给出一个致命的错误，二 include() 只是给出一个警告
两者的两个变体函数，require_once() 和 include_once() 
确保一个被引用的文件只能被引入一次。
这两个函数可以防止错误的引入同样的函数库两次，从而出现重复函数定义的错误，如果关心编码实践，最好不要使用require() 和 include() ，因为require_once() 和 include_once()的运行速度更快

引用传递、值传递
函数参数调用的方式常规方式是值传递
可以通过在函数定义的参数名前加一个“&”来指定参数的按引用传递，不许要对函数调用方式改变
值传递：
function increment($value,$amount=1){
	$value = $value + $amount;
}
引用传递：
function increment(&$value,$amount=1){
	$value = $value + $amount;
}

关键字 “return” 将终止函数的执行

#### 内置函数
### isset()  phpinfo()  
###	reset current end next prev each foreach 
### substr strstr($headeValue,"Chrome")

#### 面向对象
class ClassName{}
__construct
__destruct
new 
$this
private
protected
public
static
extends
final
interface
implement
->   
::

### 类 VS 对象
类是虚拟的，对象是实体；
都是由属性和方法构成；
在现实中，现有对象后有类，在计算机中，现有类，后又对象；
## 类  class ClassName{	}
class 是声明类的关键字；
类名、函数名、关键字 都不区分大小写；
ClassName 类名，由数字、字母、下划线 构成，不能以数字开头，尽量使用 “驼峰式” 命名，后面不用加 “()”；

class Student{
	public $name = "张梦磊";
	public $sex = "男";
	public function showInfo(){
		echo "{$this->name}的性别是{$this->sex}";
	}
}

## 类的成员属性
成员属性 VS 普通变量：成员属性有前提（谁的属性），成员属性要加权限控制符
权限控制符 变量名 = 变量值;
权限控制符：主要用来保护数据的安全；
public(公共权限) ： 在 类内部、类外部 和 子类 中都可以使用；
protected(受保护的权限) ： 在 类内部 和 子类 中可以使用；
private(私有权限) ： 只能在 类内部 使用；

## 类的 成员方法
成员方法 VS 普通函数 ： 成员方法以类为前提，不可以当单独存在；要加权限控制符（public 可以省略，建议不要省略）；
权限控制符 function functionName(形参1，形参2，...){ }

## 实例化对象  使用new关键字  $obj = new ClassName();
类可以产生N个对象；类几乎不占内存，但是对象要占用内存；对象才可以帮助我们做任务，而不是类。

## 对象 属性 和 方法 的操作  $obj -> functionName();

## 伪变量  $this 
PHP中，$this 代表当前对象，用来调用对象的属性和方法，只能在成员方法中使用，

## 类的常量 	const 常量名(全大写) = 常量值；
常量不能修改，也不能删除；define修饰的常量是全局变量；是类的常量，与对象无关，只能通过类名调用(ClassName::常量名);类常量在内存中只有一份，不会随着对象的增加而增加，可以被所有的对象共享，可以节省空间；类常量没有权限符；一般被认为是局部变量；常量名不加 $ ；常量的值必须是固定的值；

## 静态属性和静态方法  static 关键字修饰的属性和方法
是类的属性和方法，与类有关，与对象无关，通过类名调用(ClassName::静态属性或静态方法)；在内存中只有一份，不随着对象的增加而增加；静态属性的值是可以改变的，可以被所有对象共享；要加权限控制符；

## self关键字 代表当前类
$this : 用来调用对象的东西(成员属性，成员方法); 使用 "->" 调用 ; 只能在成员方法中；
self : 用来调用类的东西(类常量，静态属性，静态方法); 使用 "::" 调用 ; 可以在成员方法中 和 静态方法中；

## 构造方法    public function __construce(){}  是成员方法  没有返回值

## 析构方法    public function __destruce(){}  是成员方法  

## OPP中内存的分配情况

## 值传递 和 引用传递
PHP 有 8 种数据类型：
变量数据类型：字符串类型，整形，浮点型，布尔型；
复合数据类型：数组，对象；
特殊数据类型：资源，NULL；
值传递：字符串类型，整形，浮点型，布尔型，数组；
引用传递：资源，对象；
PHP中，使用 & 符号，可以将标量数据类型和数组变成引用传递；

## 类的封装性
将敏感数据保护起来，不被外界访问；
将一个功能的方方面面封装成一个类；
类的封装性实现，就是通过权限控制符列实现；
在项目中，所有成员属性一般都是 private 和 protected 权限；

成员属性 和 静态属性 必须要加权限控制符，不能省略；
成员方法 和 静态方法 可以不加权限控制符，默认public，建议不要省略；

## 类的继承性 extends 实现功能的升级和扩展  class SubClass extends ParentClass{ }

PHP 和 Java 都是单继承；C++可以是多进程；

## 类的多态   主要是指 方法重载 和 方法重写
函数重载 ： 在一个脚本文件中，定义两个同名的函数 （PHP不支持）；
方法重载 ： 在同一个类中，定义两个同名方法 （PHP不支持）；
方法重写 ： 父类有一个方法，在子类用同样的名称再定义一次，用于功能升级。

# 方法重写的要求
重写的前提是继承父类；
方法名称、参数个数、类型 要与父类保持一致；
权限不能低于父类中的权限；父类中是public，子类中必须为public，父类中是protected，子类中是public或者是protected，父类是private，则子类无法继承；

## 最终类 和 最终方法 final
最终类不能被继承，直接实例化；
最终方法不能被重写，直接调用；
最终类 和 最终方法 不能同时加final关键字；

## 抽象类 和 抽象方法 abstract
抽象类只能被继承，不能被实例化；常用语基础类；
抽象方法：该方法没有方法体，抽象方法必须先继承，后重写；
如果一个类中有一个抽象方法，该类必须声明为抽象类；

## 接口技术  因为PHP只支持单继承
接口就是特殊的抽象类
interface关键字，声明一个接口，接口是一种特殊类
implements关键字，创建一个子类，来实现接口
同类的东西使用extends关键字，不同类的东西使用implements关键字
子类继承父类，接口继承接口，类实现接口
接口中只能存在两样东西：类常量和抽象方法
接口中的方法，默认都是抽象方法，因此不加abstract关键字
接口中方法的权限必须是public
接口中方法，可以是成员方法，也可以是静态方法
接口中所有的抽象方法，在子类中必须要重写
接口中的常量不能重写，只能继承

PHP中的重写，不一定是方法重写，还可以是常量重写，静态属性重写，静态方法重写


// 定义第一个接口
interface Inter1
{
	const TITLE = '全站';
	public function showInfo($a,$b);
}
// 定义第二个接口
interface inter2
{
	public static function readMe();
}
// 创建抽象学生类。并实现多个接口
abstract class Student implement Inter1,Inter2
{
	public function showInfo($name,$age){}
	public static function readMe(){}
}
final class ItcastStudent extends Student{}
$obj = new ItcastStudent();



interface XiaoLingTong
{
	public function tel();
}
interface Mp3
{
	public function music();
}
interface Mp4 extends Mp3
{
	public function video();
}
class Mobile implements XiaoLingTong,Mp4
{
	public function tel(){
		echo '打电话';
	}
	public function music(){
		echo '听音乐';
	}
	public function video(){
		echo '看电影';
	}
	public function game(){
		echo '打游戏';
	}
}
$obj = new Mobile();
$obj -> tel();
$obj -> music();
$obj -> vodie();
$obj -> game();

## 类的自动加载 __autoload()    不需要一个一个的加载（require)
# 类文件命名规则
每一个功能大度定义成一个类文件
每一个类文件尽量以 .class.php 结尾。  Student.class.php
类文件的主名要与类名称操持一致.    class Student{}
类命名采用驼峰方式，首字母大写（class ConnMysql），方法和属性命名采用驼峰方式，首字母小写，

__autoload() 是系统文件，不是方法，名称是固定的；

<?php
    header("content-type:text/html;charset=utf-8");
    function __autoload($className){
        $filename = "./class/$className.class.php";
        if(file_exists($filename)) require_once($filename);
    }
    $stuObj = new Student();
    $teaSch = new School();
?>

## 自定义类文件加载函数 (sql_autoload_register)
__aotoload() 有点局限性，如果类文件位于不同的目录，类文件名命名方式也不尽相同；
自定义类文件加载函数：sql_autoload_register() 主要应用在项目中，可以应对不同的情况；
sql_autoload_register() 注册多个类加载函数，形成了一个列文件的队伍，按照注册的顺序，一次执行，哪个类文件存在，就包含哪个类文件；
每个函数就是一种列文件的加载规则；



## 对象克隆
创建新对象有两种方式：使用new关键字；使用clone关键字



## 面向对象设计模式 (单例模式/工厂模式)
常用的设计模式：
1、单例模式：一个类只能创建一个对象，无论用什么方法，都不能创建第二个对象；
2、工厂模式：根据传递的不同类名，来创建不同类的对象的工厂；

单例模式:三私一公
一私：私有的 静态的 保存对象的属性；
一私：私有的构造方法，阻止类外new对象；
一私：私有的克隆方法，阻止类外clone对象；
一公：公共的 静态的 创建对象的方法；

class Db
{
	private static $obj = NULL;
	private function __construct(){}
	private function __clone(){}
	public static fucntion getInstance(){
		if(!self::$obj instancelf self){
			self::$obj = new self;
		}
		return self::$obj;
	}
}
$db = Db::getInstance();

instanceof 关键字
判断一个对象是不是某一个类产生的对象   返回 true 或者 false
$obj instanceof ClassName

### 序列化和反序列化
把对象或者数组进行序列化存储，反序列化输出；
序列化（串行化）：是将变量转换为可保存或传输的字符串的过程；
反序列化（反串行化）：就是在适当的时候把这个字符串再转化成原来的变量使用。
常见的php系列化和反系列化方式主要有：serialize，unserialize；json_encode，json_decode。 













面向对象引入了 分类、关系和属性 ，帮助程序的开发和代码重用
类是表示彼此之间可能互不相同，但是必须具有一些共同点的对象的集合
构造函数 __construct(){}
析构函数 __destruct(){}
类的实例化
使用 new 来创建一个对象，还需要为构造函数提供所有要的参数
如果构造函数中需要参数，则实例化对象的时候必须要带参数
使用类的属性  $this

$a = new classname();
$b = $a -> function();

public    公有，属性和方法在内部和外部都可以使用
protect	  受保护，可以被继承，但只能在继承内部使用
private	  私有，只能在类内部直接进行访问，不可以继承

继承  class A extends B   

class A
{
	private function function1()
	{
		echo "private";
	}
	protected function finction2()
	{
		echo "protect";
	}
	public function funciton3()
	{
		echo "public";
	}
}

class B extends A
{
	function __construct()
	{
		$this -> function1();     //  不可以这样使用，private 不可以在子类中使用
		$this -> function2();
		$this -> function3();
	}
}

$b = new B();
$b -> function2();    // protected 修饰的方法只能在子类内部使用
$b -> function3();

覆盖	子类中重新定义了部分父类中的属性和方法

final  
final 修饰的函数， 这个函数不可以在任何子类中被覆盖
final 修饰的类，这个类禁止被继承

PHP 不支持多重继承，一个子类不可以继承两个或者多个父类

接口可以弥补 PHP不支持多重继承 的缺陷  interface

接口的方法必须是公开的；
接口的方法默认是抽象的，所以不需要再方法名前面加 abstract；
接口可以定义常量，但不能定义成员属性，接口的定义和用法和类中常量一样；
类可以实现多个接口（相当于把多个功能集于一身，如手机是吸纳了小灵通、MP3、MP4的功能）；
接口可以继承接口；

所有的接口都需要使用HTTPS协议，JSON数据格式、UTF8编码
请求方式：标明接口调用的HTTP方法，分区HttpGet/HttpPost请求，所有的请求都为HTTPS协议；
请求地址：
请求包体/参数说明：
权限说明：
返回结果/参数说明


一个类可以组合多个 trait ， 而trait可以继承其他的trait

trait logger
{
	public function logmessage($message,$level = "DEBUG")
	{
		echo "trait";
	}
}

class login
{
	use logger;
	function sore($data)
	{
		// ...
		$this -> login($msg);
	}
}

面向对象的php
访问一个对象中的数据只能通过对象的操作来实现，对象的操作也就是对象的接口
一个对象的功能取决于对象使用的数据


类
通过在类的定义中使用关键词var来声明变量，可以创建属性
class class_name
{
	var $attribute1;
	var $attribute2;
}
构造函数：当创建一个对象时，他将调用构造函数，通常，这将执行一些有用的初始化任务    function __construct(){}
析构函数：与构造函数相对，（php5新加的内容），他们允许在销毁一个类之前执行一些操作或完成一些功能，这些操作或者功能通常早所有对该类的引用都被重置或者超出作用域时自动发生（ __destruct() ），洗后函数不能带任何参数

类的实例化
在声明一个类后，需要创建一个对象——一个特定的个体，即类的一个成员——并使用这个对象，这也叫做穿件一个实例或者实例化一个类，可以使用一个关键词new来创建一个对象，需要指定创建对象时哪一个类的实例，并且通过构造函数提供任何所需要的参数
如下所示的代码声明了一个具有构造函数、名为classname的类、然后有创建了3个classname类型的对象
class classname
{
	function __construct($param)
	{
		echo "Constructor called with paremeter $param <br/>";
	}
}
$a=new classname("First");
$a=new classname("Second");
$a=new classname("");

由于在每次创建一个对象时都将调用这个构造函数，以上代码将产生如下的输出：
Constructor called with parameter First
Constructor called with parameter Second
Constructor called with parameter


使用类的属性
在一个类中可以访问一个特殊的指针——$this.如果当前类的一个属性为$attribute，则当在该类中通过一个操作设置或者访问变量时，可以使用 $this->attribute来引用
如下所示的代码说明了如何在一个类中设置和访问属性：
class classname
{
	var $attribute;	// 声明变量
	function operation($param)
	{
		$this->attribute=$param
		echo $this->attribute;
	}
}

**避免使用中文目录和中文文件名**
## php 变量
	1、变量以$开头 字母/数字/下划线 不能以数字开头
	2、大小写敏感（区分大小写）
## 数据类型
	字符型、整型、浮点型、布尔型、数组、索引数组、关联数组（了解即可）
## 内容输出
	echo：输出简单数据类型，如字符串、数值
	print_r()：输出复杂数据类型，如数组
	var_dump()：输出详细信息，如对象、数组（了解）
## 运算符
	基本与Javascript语法一致
	.号表示字符串拼接符，Javascript中为+号。
## 函数
	与Javascript基本一致函数名对大小写不敏感默认参数（了解即可）。
## 分支 循环语句
	与Javascript基本一致foreach()
## 表单处理
	表单name属性的是用来提供给服务端接收所传递数据而设置的
	表单action属性设置接收数据的处理程序
	表单method属性设置发送数据的方式
	当上传文件是需要设置 enctype="multipart/form-data"，且只能post方式
	$_GET接收 get 传值
	$_POST接收 post 传值
	$_FILES接收文件上传
## 常用PHP函数
	in_array() 是否在数组中
	$arrs=array("1","2","3");
	//判断1 这个元素是否存在$arrs 这个数组当中。
	echo in_array("1",$arrs);

	count() 计算数组长度
	$arrs=array("1","2","3");
	count($arrs);

	array_key_exists ()检测数组中是否存在key
	$arrs=array("username"=>"张三","age"=>11);
	echo array_key_exists("username",$arrs);

	file_get_contents读取文件
	$data=file_get_contents("hello.txt");
	echo $data;

	move_uploaded_file**($file,**"images/"**.$fileName);
	
## 常见的数据库产品
## Orcale数据库
	Orcale数据库管理系统由**甲骨文公司**开发，在数据库领域一直处于领先地位。
	大型的商业型数据库，目前国内一些大公司在用，国企
	淘宝、京东等都有使用，一个很老牌的数据库，稳定
## SqlServer数据库
	由微软公司开发，只能在Windows上运行。.net程序员。
	但是，微软现在已经把SqlServer移植到了别的平台，例如：Linux
## DB2数据库
	由IBM公司开发，在**金融行业**中使用的比较多。IBM的服务器，买服务器送数据库。
	IBM靠硬件发家的，小型机。小型服务器
	比较稳定
## MySQL数据库
	MySQL数据管理系统由瑞典的MySQLDB公司开发，但是几经辗转，现在已经是Oracle的产品了。
	开源、免费、轻量
	MySQL具有跨平台的特性，不仅可以在Windows平台上使用，还可以在Unix、Linux和Mac OSX平台上使用。
	相对其它数据库而言，MySQL的使用也更加方便、快捷而且MySQL免费所以**运营成本低**，因此很多公司都在用MySQL。
	Oracle收购过来之后，发行了两个版本：
	​	一个是企业版，公司买了之后，Oracle公司可以提供一些服务，例如数据恢复，或者说存储数据出现了问题
	​	一个社区版，也就是免费开原版
## MongoDB数据库
	mongodb是一种非关系型数据库，简称NoSQL
	存储方式，不是数据库-表-记录了
	mongod的存储方式是：数据库-集合-实体（随便存储，就像json对象一样）
	MongoDB是由10gen公司开发的一个介于关系型数据库和非关系型数据库之间的产品，是非关系型数据库中功能最丰富，最像关系型数据库的。
	他支持的数据结构非常松散，是类似json的格式，所以可以存储比较复杂的数据结构类型。
	MongoDB数据库管理系统最大的特点就是它支持的查询语言非常强大，语法类似于面向对象的查询语言。
	它还是一个开源的数据库，对于大数据量、高并发的互联网应用，支持非常不错。
## 操作非关系型数据库不需要使用SQL语言
##  MySQL目录结构
	bin：可执行文件所在目录
	data：数据文件所在目录
	Docs：文档目录
	share：存放字符集等信息
	my.ini：MySQL数据库使用的配置文件
## 文件上传客户端的要求
  - 必须表单提交
  - 必须是 post 方式提交
  - 当上传文件是需要设置 enctype="multipart/form-data"
  - 必须有一个input  type=file 的属性
## 文件上传服务器处理数据  
  使用$_FILES接收文件上传 接收文件上传的数据。move_uploaded_file
	header("Content-Type:text/html;charset=utf-8");          
	//var_dump($_FILES);
	$_FILES=array(
		"lifephoto"=>
		array(
		name=>"", 客户端传递的文件的名称
		type=>"image/jpeg", 客户端传递的文件类型
		tmp_name=>"",  客户端传递的文件在服务端临时的一个保存地址
		error=>"0"  文件上传的时候可能会发生失败，出错误
		size=>"10823" 客户端上传的 文件的大小
		)
	);
  1.1 获取文件上传的数据
  $fileName=$_FILES["lifephoto"]["name"];
  1.2 获取文件上传的时候在服务器端临时的存储位置
  $tmpaddress=$_FILES["lifephoto"]["tmp_name"];
  2：接收到文件上传的数据之后，我们怎么去处理这些数据.，实际上要把客户端上传的数据保存在服务端的硬盘上面.
  2.1 怎么去保存，php 提供了一个函数 move_uploaded_file，可以将文件上传的数据移动到指定的某个目录文件下面接收两个参数
  1:临时的文件存放的地址
  2:我要放在的目标位置, images/1.jpg

  move_uploaded_file($tmpaddress,"images/".$fileName);

  3：响应数据
  echo "<font color='green'>恭喜你，文件上传成功</font>";
## 网络通讯协议
  指服务器和客户端间进行通信时的约束和规范，客户端与服务端的数据交互并不是杂乱无章的，需要遵照（基于）一定的规范进行。
## 常见协议
  1、HTTP、HTTPS 超文本传输协议 
  2、FTP 文件传输协议
  3、SMTP 简单邮件传输协议
  4、即时通讯协议XMPP
## http 协议 
  即超文本传输协议，网站是基于HTTP协议的，例如网站的图片、CSS、JS等都是基于HTTP协议进行传输的。
  HTTP协议是由从客户机到服务器的请求(Request)和从服务器到客户机的响应(Response)进行了约束和规范。
  即HTTP协议主要由请求和响应构成。
  常用请求方法 POST、GET、PUT、DELETE
##  **请求/请求报文**
  请求由客户端发起，其规范格式为：请求行、请求头、请求主体。
  1、请求行	由请求方式、请求URL和协议版本构成
  2、请求头	Host：localhost请求的主机
		Cache-Control：max-age=0控制缓存
		Accept：*/* 接受的文档MIME类型
		User-Agent：很重要
		Referer：从哪个URL跳转过来的
		Accept-Encoding：可接受的压缩格式
  3、请求主体	即传递给服务端的数据
  **注：当以post形式提交表单的时候，请求头里会设置**
  **Content-Type: application/x-www-form-urlencoded，以get形式当不需要**
## 特殊的请求头介绍：
  Content-Type:""
  referer: 请求头
  refresh 响应头
  Content-Type: 响应头
## **响应/响应报文**
  响应由服务器发出，其规范格式为：状态行、响应头、响应主体。
  1、状态行	由协议版本号、状态码和状态信息构成
  2、响应头
		Date：响应时间
		Server：服务器信息
		Content-Length：响应主体长度
		Content-Type：响应资源的MIME类型
  **MIME是标识文件类型的，文件后缀并不能正确无误的标识文件的类型。**
  **客户端与服务器在进行数据传输的时候都是以字节形式进行的，咱们可以理解成是以“文本形式”传输，这时浏览器就需要明确知道该怎么样来解析这些文本形式的数据，MIME就是明确告知浏览器该如何来处理。**
  3、响应主体
  即服务端返回给客户端的内容；
  状态码
  常见的有200代表成功、304文档未修改、403没有权限、404未找到、500服务器错误,302 代表的是请求重定向。
## **调试工具**
  利用HTTP抓包工具在开发中可以帮我们进行调试，常用抓包工具HttpWatch、Fiddler、Charles、FireBug等
  **浏览器插件**
  Firebug、HttpWatch、chrome dev tools
  **代理软件**
  Charles、Fiddler
## get 请求与post 请求介绍
	1: get 发送的数据都在地址栏当中，不安全
	2：get 发送的数据对数据大小由限制。
	3：get 没有请求体
	4：post 发送的数据在请求体当中，相对安全
	5：post 对请求的数据的大小没有限制
	6：post 有一个特殊的请求头 Content-Type:application/x-www-form-urlencoded
	7: get 的请求头相对较少，性能稍微要高一些.
	案例1
	//解决乱码，给客户端一个响应头
	header("Content-Type:text/html;charset=utf-8");
	//1:获取请求头 获取所有的请求头.
	$arrHeader=getallheaders();
	//2:我获取的是User-Agent 请求头对应的值
	$headeValue=$arrHeader["User-Agent"];
	// echo $headeValue;
	//3:php 里面有一个函数 strstr() 判断字符串是否包含指定的字符串.
	if(strstr($headeValue,"Chrome")){
		echo "您当前使用的google 浏览器，棒棒哒!";
	}else if(strstr($headeValue," Firefox")){
		echo "您当前使用的火狐 浏览器，双击666";
	}else if(strstr($headeValue,"MSIE")){
		echo "您当前使用的浏览器版本较低，请<a href='http://www.360.com'>升级</a>";
	}
	案例2
	<?php
		header("Content-Type:text/html;charset=utf-8");
		//1:给一个响应头
		header("Refresh:5;url=http://www.baidu.com");
		//2：给文字提示.
		echo " <span>5</span> 秒钟之后会自动跳转页面，如果没有跳转，请点击<a href='http://www.baidu.com'>这里</a>";
	?>
	<script>
		var i=5;
		var ids=window.setInterval(function(){
			i--;
			if(i==0){
				window.clearInterval(ids);
				return;
			}
			document.querySelector("span").innerHTML=i;
		},1000);
	</script>
    
    
### php中的mysql 常用命令学习
	CREATE DATABASE IF NOT EXISTS RUNOOB DEFAULT CHARSET utf8 COLLATE utf8_general_ci;  // 创建RUNOOB数据库，并设定编码集为utf8
	create table if not exists db_person (
		id int(20)  primary key auto_increment not null,
		name varchar(20) not null
	); 
	//修改表结构
	alter
	//重命名表
	rename table db_person to db_persons;
	//插入
	insert into db_persons (id,name) value (0,"tom");
	create table if not exists db_person(
		id int auto_increment primary key,
	  	username varchar(50) not null,
		password varchar(50) not null,
		email varchar(50) not null);
	insert into db_person (username,password) values ('tom','123456');
 
//选择数据库
	<?php
		$dbhost = 'localhost:3306';  // mysql服务器主机地址
		$dbuser = 'root';            // mysql用户名
		$dbpass = '123456';          // mysql用户名密码
		$conn = mysqli_connect($dbhost, $dbuser, $dbpass);
		if(! $conn ){
		    die('连接失败:'.mysqli_error($conn));
		}
		echo '连接成功';
		mysqli_select_db($conn, 'RUNOOB' );
		mysqli_close($conn);
	?>
//创建表
	<?php
		$dbhost = 'localhost:3306';  // mysql服务器主机地址
		$dbuser = 'root';            // mysql用户名
		$dbpass = '123456';          // mysql用户名密码
		$conn = mysqli_connect($dbhost, $dbuser, $dbpass);
		if(! $conn )
		{
		    die('连接失败: ' . mysqli_error($conn));
		}
		echo '连接成功<br />';
		$sql = "CREATE TABLE runoob_tbl( ".
			"runoob_id INT NOT NULL AUTO_INCREMENT, ".
			"runoob_title VARCHAR(100) NOT NULL, ".
			"runoob_author VARCHAR(40) NOT NULL, ".
			"submission_date DATE, ".
			"PRIMARY KEY ( runoob_id ))ENGINE=InnoDB DEFAULT CHARSET=utf8; ";
		mysqli_select_db( $conn, 'RUNOOB' );
		$retval = mysqli_query( $conn, $sql );
		if(! $retval )
		{
		    die('数据表创建失败: ' . mysqli_error($conn));
		}
		echo "数据表创建成功\n";
		mysqli_close($conn);
	?>
//添加数据
	<?php
		$dbhost = 'localhost:3306';  // mysql服务器主机地址
		$dbuser = 'root';            // mysql用户名
		$dbpass = '123456';          // mysql用户名密码
		$conn = mysqli_connect($dbhost, $dbuser, $dbpass);
		if(! $conn )
		{
			die('连接失败: ' . mysqli_error($conn));
		}
		echo '连接成功<br />';
		// 设置编码，防止中文乱码
		mysqli_query($conn , "set names utf8");
		$runoob_title = '学习 Python';
		$runoob_author = 'RUNOOB.COM';
		$submission_date = '2016-03-06';
		$sql = "INSERT INTO runoob_tbl ".
			"(runoob_title,runoob_author, submission_date) ".
			"VALUES ".
			"('$runoob_title','$runoob_author','$submission_date')";
		insert into db_person (firstname,lastname,email) values ('tom','jery','709@.com');
		mysqli_select_db( $conn, 'RUNOOB' );
		$retval = mysqli_query( $conn, $sql );
		if(! $retval )
		{
		  	die('无法插入数据: ' . mysqli_error($conn));
		}
		echo "数据插入成功\n";
		mysqli_close($conn);
	?>
//查询数据
	<?php
		$dbhost = 'localhost:3306';  // mysql服务器主机地址
		$dbuser = 'root';            // mysql用户名
		$dbpass = '123456';          // mysql用户名密码
		$conn = mysqli_connect($dbhost, $dbuser, $dbpass);
		if(! $conn )
		{
		    die('连接失败: ' . mysqli_error($conn));
		}
		// 设置编码，防止中文乱码
		mysqli_query($conn , "set names utf8");
		$sql = 'SELECT runoob_id, runoob_title,runoob_author, submission_dateFROM runoob_tbl';
		mysqli_select_db( $conn, 'RUNOOB' );
		$retval = mysqli_query( $conn, $sql );
		if(! $retval )
		{
			die('无法读取数据: ' . mysqli_error($conn));
		}
		echo '<h2>菜鸟教程 mysqli_fetch_array 测试<h2>';
		echo '<table border="1"><tr><td>教程 ID</td><td>标题</td><td>作者</td><td>提交日期</td></tr>';
		while($row = mysqli_fetch_array($retval, MYSQLI_ASSOC)){
			echo "<tr><td> {$row['runoob_id']}</td> ".
			"<td>{$row['runoob_title']} </td> ".
			"<td>{$row['runoob_author']} </td> ".
			"<td>{$row['submission_date']} </td> ".
			"</tr>";
		}
		echo '</table>';
		mysqli_close($conn);
	?>

## 注册（向数据库中添加数据）
## 注销
## 修改密码 (更改数据库的数据);
## 登录 (从数据库里面查询一条记录)
## 请求方式  POST GET  通过name属性进行数据传输   $password=$_POST['password'];
## 接收请求，处理请求，完成响应.
## 响应的数据防止页面文字乱码
	header('Content-Type:text/json;charset=utf-8');
## 给客户端一个响应头，响应json 格式的数据.
	header('Content-Type:application/json;charset=utf-8');
## 连接数据库
	$con = mysql_connect("127.0.0.1","root","");
	if (!$con){
		die('Could not connect: ' . mysql_error());
	}
## 连接 database_name
	mysql_select_db("database_name", $con);
## sql 语句
	$sql="INSERT INTO teacher (username, telephone, age,t_desc) VALUES
	('$_POST[username]','$_POST[telephone]','$_POST[age]','$_POST[desc]','$_POST[lifephoto]')";
## 通过连接发送sql语句;     $result = mysql_query($sql,$con)
	if (!mysql_query($sql,$con)){
		die('Error: ' . mysql_error());
	};
## 把数据库里面返回的结果$result 遍历出来
	while($row = mysql_fetch_array($result)){
	$item = array(
		'id' => $row['id'],
		'username' => $row['username'],
		'telephone' => $row['telephone'],
		'age' => $row['age'],
		't_desc' => $row['t_desc'],
		'lifephoto' => $row['lifephoto'],
	);
## 往数组里面添加一条记录.
	array_push($list,$item);
## 关闭跟数据库的连接
	mysql_close($con);
## cookie 概念
​	简单来说，Cookies就是服务器暂时存放在你的电脑里的资料（.txt格式的文本文件），好让服务器用来辨认你的计算机。当你在浏览网站的时候，Web服务器会先送一小小资料放在你的计算机上，Cookies 会把你在网站上所打的文字或是一些选择都记录下来。当下次你再访问同一个网站，Web服务器会先看看有没有它上次留下的Cookies资料，有的话，就会依据Cookie里的内容来判断使用者，送出特定的网页内容给你。 
## 具体作用:
	​http 协议是基于请求响应的协议，请求-->响应，连接断开。没有办法记录客户端的状态。
	也就没有办法对用户的行为进行跟踪，可以根据cookie 对用户进行状态的跟踪。
	cookie流程：当第一次访问服务器，服务器可以向客户端发送cookie，可以往cookie 当中存入需要的数据。
	客户端如果接收到服务器端响应的cookie，会把cookie 自动保存起来。当客户端再次请求服务器的时候，
	浏览器会自动把客户端cookie 的数据发送到服务器。
## 内存cookie
	setcookie("user", "zhuwu"); 
## 硬盘cookie
	setcookie("username","zml",time()+60*60*24);   // 一天
## 追杀cookie
	setcookie("user", "",-1);
## 服务端发送cookie 
	setcookie("user", "zml", time()+3600);
## 客户端获取cookie
	var cookies=document.cookie;
## session 
	代表的就是一次会话（打开网站，访问网站时会话开始，在这个网站当中可能发送多次请求，直至关闭浏览器会话结束。）
	​在一个站点发送两次请求，但是每个请求都是独立的，之间是不能共享数据，使用session 会话，让两个请求之间可以共享数据。
## 为什么要用session：
	Http协议是无状态的，也就导致服务器无法分辨是谁浏览了网页。为了维持用户在网站的状态，比如登陆、购物车等，
	出现了先后出现了四种技术，分别是隐藏表单域、URL重写、cookie、session。
	session和cookie都是用来解决Http协议不能维持状态的问题，但是session只存储在服务器端的，不会在网络中进行传输，所以较cookie来说，session相对安全一些。
## php 服务器端创建会话
	session_start();  // 会话开始
	$_SESSION[]	     // 往改数组里面保存数据。	
	session 在php里面默认时间是24分钟。 24分钟指的是发呆时间，每次使用会重新计时
	php.ini中
		可以更改session默认时间 (setting session.gc_maxlifetime to 1440 (1440 seconds = 24 minutes))
		也可以更改session存储处路径 （session.save_path ="D:/wamp64/tmp"）
	session用途
	1、网上商城的购物车
	2、保存用户的登录信息
	3、将某些数据放到session中，供一个用户的各个页面使用
	4、防止用户非法登录到某个页面
	。。。
	每次使用session是都需要确保session初始化 session_start();
## 模拟创建session
	<?php
        //用户登录，登录成功了.
        $username="陈好";
        //我要把这个数据保存在会话里面。我要存在session 当中.
        //开始一次会话.
        session_start();
        //这个是一个关联数组.
        $_SESSION['username']=$username;
	?>
## 输出session
	<?php
		header("Content-Type:text/html;charset=UTF-8");
		session_start();
		if(!empty($_SESSION['username'])||!empty($_SESSION['password'])){
			echo $_SESSION['username'];
			echo $_SESSION['password'];
		}else{
			echo "没有session";
		}
	?>
## 删除session  （session_destroy();）  （unset($_SESSION["username"]);）
	<?php
		session_start();
		session_destroy();  // 删除所有的session
		unset($_SESSION["username"]);  // 删除对应的session

	?>
## 实际应用
	保存用户登录的状态，如果登录成功，服务器把user 保存在   $_SESSION[]	 当中。
## cookie 与session 对比 
	cookie   是存储在客户端，它是服务器想客户端保存数据。比如记住用户名。
	sessionStroage    客户端的存储，基于html5 ，也是本地存储。生命周期。
	localstorage   本地存储，它是实例化到本地的硬盘。
	session 存储在服务器的，依赖cookie。




	string(23) "http://192.168.0.180:55"
	string(22) "index/index/index.html"
	string(17) "index/index/index"
	string(3) "GET"
	bool(true) 
	bool(false) 
	bool(false) 
	array(2) { 
	["name"] => string(6) "chaoyi"
	["type"] => string(4) "blog"
	} 
	array(2) { 
	["name"] => string(6) "chaoyi"
	["type"] => string(4) "blog"
	} 
	array(0) { 
	} 
	array(1) { 
	["name"] => string(10) "onestopweb"
	} 
	array(3) { 
	["username"] => string(6) "chaoyi"
	["PHPSESSID"] => string(26) "nugcsr2j9krr2lhk8bntggl412"
	["email"] => string(18) "onestopweb@163.com"
	} 
	string(4) "blog"
	string(18) "onestopweb@163.com"
	string(5) "index"
	string(5) "Index"
	string(5) "index"
	string(45) "/index/index/index.html?name=chaoyi&type=blog"
	string(23) "/index/index/index.html" 




    $(document).ready(function(){
        // 添加角色
        var options = {
            beforeSubmit:showStart,
            success:showSuccess
        };

        $('#commentForm').submit(function(){
            $(this).ajaxSubmit(options);
            return false;
        });

        $('#keywords').tagsinput('add', 'some tag');
        $(".bootstrap-tagsinput").addClass('col-sm-12').find('input').addClass('form-control')
            .attr('placeholder', '输入后按enter');


        // var editor = UE.getEditor('container');
    });



	    // 表单验证
    $.validator.setDefaults({
        highlight: function(e) {
            $(e).closest(".form-group").removeClass("has-success").addClass("has-error")
        },
        success: function(e) {
            e.closest(".form-group").removeClass("has-error").addClass("has-success")
        },
        errorElement: "span",
        errorPlacement: function(e, r) {
            e.appendTo(r.is(":radio") || r.is(":checkbox") ? r.parent().parent().parent() : r.parent())
        },
        errorClass: "help-block m-b-none",
        validClass: "help-block m-b-none"
    });


    * 随机数
      */
     function random (m,n){
         return Math.floor(Math.random()*(m - n) + n);
     }

if(request()->isAjax()){

}


{if authCheck('order/orderadd')}
<a href="{:url('order/orderadd')}"><button class="btn btn-outline btn-primary" type="button">添加订单</button></a>
{/if}


{if authCheck('order/orderadd')}
<a href="{:url('order/orderadd')}"><button class="btn btn-outline btn-primary" type="button">添加订单</button></a>
{/if}



$param = input('post.');
$user_id = Session::get('user_id');
if (!preg_match('/^[1-9]\d*|^[1-9]\d*.\d+[1-9]$/', $param['place'])) {
	return json(msg(-1, '', '只能是纯数字'));
}
if(!isset($param['type'])) return json(msg(-1, '', '请选择分配方式'));




#### 企业微信
所有的接口需要使用 HTTPS协议 、 JSON数据格式 、 UTF8编码
开发者应特别留意调用场景。比如，同步通讯录的接口必须要用通讯录同步助手的access_token，发送消息指定的范围必须是应用可见范围内的结点等。
所有接口返回包里都有errcode、errmsg。开发者需根据errcode是否为0判断是否调用成功（errcode意义请见全局错误码）。而errmsg仅作参考，后续可能会有变动，因此不可作为是否调用成功的判据
### 区分三种类型access_token
在第三方应用开发提供的接口中，会涉及到三种类型的access_token。下面表格对这三类token的定义及使用场景进行说明，开发者应在不同场景中选择对应的token：

类型	说明	适用场景
## 服务商的token	
以corpid（服务商CorpID）、provider_secret（服务商密钥）换取provider_access_token，代表的是服务商的身份	
用于服务商级别的接口调用，比如登录授权、推广二维码等。参考文档：https://work.weixin.qq.com/api/doc/90001/90143/91200

请求方式：POST（HTTPS）
请求地址： https://qyapi.weixin.qq.com/cgi-bin/service/get_provider_token

{
	"provider_access_token":"enLSZ5xxxxxxJRL",
	"expires_in":7200
}

## 第三方应用的token	
以suite_id（第三方应用ID）、suite_secret（第三方应用密钥）换取suite_access_token，代表第三方应用的身份
用于获取第三方应用的预授权码，获取授权企业信息等。参考文档：https://work.weixin.qq.com/api/doc/90001/90143/90600

由于第三方服务商可能托管了大量的企业，其安全问题造成的影响会更加严重，故API中除了合法来源IP校验之外，还额外增加了suite_ticket作为安全凭证。
获取suite_access_token时，需要suite_ticket参数。suite_ticket由企业微信后台定时推送给“指令回调URL”，每十分钟更新一次，见推送suite_ticket。
suite_ticket实际有效期为30分钟，可以容错连续两次获取suite_ticket失败的情况，但是请永远使用最新接收到的suite_ticket。
通过本接口获取的suite_access_token有效期为2小时，开发者需要进行缓存，不可频繁获取。


请求方式：POST（HTTPS）
请求地址： https://qyapi.weixin.qq.com/cgi-bin/service/get_suite_token

{
    "suite_id":"wwddddccc7775555aaa" ,    // 必须，以ww或wx开头应用id（对应于旧的以tj开头的套件id）
    "suite_secret": "ldAE_H9anCRN21GKXVfdAAAAAAAAAAAAAAAAAA",      // 必须，应用secret
    "suite_ticket": "Cfp0_givEagXcYJIztF6sfbdmIZCmpaR8ZBsvJEFFNBrWmnD5-CGYJ3_NhYexMyw"    // 必须，企业微信后台推送的ticket
}


## 授权企业的token
企业安装第三方应用后，第三方服务商以企业的corpid、永久授权码来获取access_token	
用于操作授权企业相关接口，如通讯录管理，消息推送等。文档参考 https://work.weixin.qq.com/api/doc/90001/90143/90605

请求方式：POST（HTTPS）
请求地址： https://qyapi.weixin.qq.com/cgi-bin/service/get_corp_token?suite_access_token=SUITE_ACCESS_TOKEN

{
	"auth_corpid": "auth_corpid_value",      // 必须，授权方corpid
	"permanent_code": "code_value"     // 必须，永久授权码，通过get_permanent_code获取
}

corpid(企业ID):每个服务商同时也是一个企业微信的企业，都有唯一的corpid。
provider_secret：作为服务商身份的调用凭证，应妥善保管好该密钥，务必不能泄漏。
suiteid/suite_secret：suiteid为应用的唯一身份标识，suite_secret为对应的调用身份密钥。
suite_ticket
suite_ticket与suite_secret配套使用，用于获取suite_access_token。
suite_ticket由企业微信后台向登记的应用指令回调地址定期推送（10分钟），用于加强调用者身份确认（即使suite_secret泄露，也无法获取到suite_access_token）。
若开发者丢失suite_ticket，除了等待定时推送的事件外，开发者也可以在管理端手动触发推送。



#### 缓存

use think\Cache;

缓存支持采用驱动方式，所以缓存在使用之前，需要进行连接操作，也就是缓存初始化操作。

$options = [
    // 缓存类型为File
    'type'  =>  'File', 
    // 缓存有效期为永久有效
    'expire'=>  0, 
    //缓存前缀
    'prefix'=>  'think',
     // 指定缓存目录
    'path'  =>  APP_PATH.'runtime/cache/',
];
Cache::connect($options);

或者通过定义配置参数的方式，在应用配置文件中添加：

'cache'  => [
    'type'   => 'File',
    'path'   => CACHE_PATH,
    'prefix' => '',
    'expire' => 0,
],
支持的缓存类型包括file、memcache、wincache、sqlite、redis和xcache。

缓存参数根据不同的缓存方式会有所区别，通用的缓存参数如下：

参数	 描述
type	缓存类型
expire	缓存有效期 （默认为0 表示永久缓存）
prefix	缓存前缀（默认为空）

设置缓存（有效期一个小时）

Cache::set('name',$value,3600);

针对数值类型的缓存数据，可以使用自增操作，例如：

// name自增（步进值为1）
Cache::inc('name');
// name自增（步进值为3）
Cache::inc('name',3);
缓存自减
针对数值类型的缓存数据，可以使用自减操作，例如：

// name自减（步进值为1）
Cache::dec('name');
// name自减（步进值为3）
Cache::dec('name',3);

获取缓存
获取缓存数据可以使用：

dump(Cache::get('name')); 
如果name值不存在，则默认返回 false。

支持指定默认值，例如：

dump(Cache::get('name','')); 
表示如果name值不存在，则返回空字符串。

删除缓存
Cache::rm('name'); 
获取并删除缓存
Cache::pull('name'); 
如果name值不存在，则返回null。

清空缓存
Cache::clear(); 
不存在则写入缓存数据后返回（v5.0.2+）
Cache::remember('name',function(){
	return time();
})

获取缓存对象
可以获取缓存对象，并且调用驱动类的高级方法，例如：

$cache = Cache::init();
// 获取缓存对象句柄
$handler = $cache->handler();

助手函数
系统对缓存操作提供了助手函数cache，用法如下：

$options = [
     // 缓存类型为File
    'type'   => 'File', 
     // 缓存有效期为永久有效
    'expire' => 0,
     // 指定缓存目录
    'path'   => APP_PATH . 'runtime/cache/', 
];

// 缓存初始化
// 不进行缓存初始化的话，默认使用配置文件中的缓存配置
cache($options);

// 设置缓存数据
cache('name', $value, 3600);
// 获取缓存数据
var_dump(cache('name'));
// 删除缓存数据
cache('name', NULL);

// 设置缓存的同时并且进行参数设置
cache('test', $value, $options);

缓存标签
支持给缓存数据打标签，例如：

Cache::tag('tag')->set('name1','value1');
Cache::tag('tag')->set('name2','value2');
// 或者批量设置缓存标签
Cache::set('name1','value1');
Cache::set('name2','value2');
Cache::tag('tag',['name1','name2']);
// 清除tag标签的缓存数据
Cache::clear('tag');

同时使用多个缓存类型
如果要同时使用多个缓存类型进行操作的话，可以做如下配置：

'cache' =>  [
    // 使用复合缓存类型
    'type'  =>  'complex',
    // 默认使用的缓存
    'default'   =>  [
        // 驱动方式
        'type'   => 'File',
        // 缓存保存目录
        'path'   => CACHE_PATH,
    ],
    // 文件缓存
    'file'   =>  [
        // 驱动方式
        'type'   => 'file',
        // 设置不同的缓存保存目录
        'path'   => RUNTIME_PATH . 'file/',
    ],  
    // redis缓存
    'redis'   =>  [
        // 驱动方式
        'type'   => 'redis',
        // 服务器地址
        'host'       => '127.0.0.1',
    ],     
],




namespace app\admin\Controller;
use app\admin\model\UserModel;


layer.msg("加载成功", {time : 1000});



   function initTable() {
        //先销毁表格
        $('#cusTable').bootstrapTable('destroy');
        //初始化表格,动态从服务器加载数据
        $("#cusTable").bootstrapTable({
            method: "get",  //使用get请求到服务器获取数据
            url: "./index", //获取数据的地址
            striped: true,  //表格显示条纹
            pagination: true, //启动分页
            pageSize: 15,  //每页显示的记录数
            pageNumber:1, //当前第几页
            pageList: [5, 10, 15, 20, 25],  //记录数可选列表
            sidePagination: "server", //表示服务端请求
            paginationFirstText: "首页",
            paginationPreText: "上一页",
            paginationNextText: "下一页",
            paginationLastText: "尾页",
            queryParamsType : "undefined",
            queryParams: function queryParams(params) {   //设置查询参数
                var param = {
                    pageNumber: params.pageNumber,
                    pageSize: params.pageSize,
                    searchText:$('#username').val()
                };
                return param;
              console.log(param);
            },
            onLoadSuccess: function(res){  //加载成功时执行
                if(111 == res.code){
                    window.location.reload();
                }
                layer.msg("加载成功", {time : 1000});
            },
            onLoadError: function(){  //加载失败时执行
                layer.msg("加载数据失败");
            }
        });
    }


#### 日志
日志记录由  \think\Log	类完成，主要完成日志记录和跟踪调试
记录了所有的运行错误
### 日志初始化
Log::init([
	'type' => 'File',    // 指定了文件方式记录日志
	'path' => APP_PATH.'logs/'     // 日志保存目录为  APP_PATH.'logs/'
]);
如果没有执行日志初始化操作，默认自动调用配置参数 log 来进行初始化操作

不同的日志类型可能会使用不同的初始化参数
Log::init([
	'type' => '\org\Log\File',
	'path' => APP_PATH.'logs/'
]);
### 日志驱动
日志可以通过驱动支持不同的方式写入，默认日志会记录到文件中，系统已经内置的写入驱动包括 File 、 Socket 
如果要临时关闭日志写入，可以设置日志类型为Test即可，例如
'log'   => [
    // 可以临时关闭日志写入
    'type'  => 'test',
],
## File驱动
日志的记录方式默认是File方式，可以通过驱动的方式来扩展支持更多的记录方式。
记录方式由log.type参数配置
为了避免同一个目录下面的日志文件过多的性能问题，file方式记录的日志文件会自动生成日期子目录。
Scoket驱动
其他驱动:thinkphp5.0支持SAE驱动的扩展
### 日志写入
手动记录
一般情况下，系统的日志记录是自动的，无需手动记录，但是某些时候也需要手动记录日志信息，Log类提供了3个方法用于记录日志。
Log::record()	记录日志信息到内存
Log::save()		把保存在内存中的日志信息（用指定的记录方式）写入
Log::write()	实时写入一条日志信息
由于系统在请求结束后会自动调用Log::save方法，所以通常，你只需要调用Log::record记录日志信息即可。
record方法用法如下：Log::record('测试日志信息');
默认的话记录的日志级别是INFO，也可以指定日志级别：
Log::record('测试日志信息，这是警告级别','notice');
采用record方法记录的日志信息不是实时保存的，如果需要实时记录的话，可以采用write方法，例如：
Log::write('测试日志信息，这是警告级别，并且实时写入','notice');
V5.0.4+版本开始，为避免内存溢出，在命令行下面执行的话 日志信息会定时自动写入。
日志级别
ThinkPHP对系统的日志按照级别来分类，并且这个日志级别完全可以自己定义，系统内部使用的级别包括：

log 常规日志，用于记录日志
error 错误，一般会导致程序的终止
notice 警告，程序可以运行但是还不够完美的错误
info 信息，程序输出信息
debug 调试，用于调试信息
sql SQL语句，用于SQL记录，只在数据库的调试模式开启时有效
系统提供了不同日志级别的快速记录方法，例如：

Log::error('错误信息');
Log::info('日志信息');
// 和下面的用法等效
Log::record('错误信息','error');
Log::record('日志信息','info');
还封装了一个助手函数用于日志记录，例如：

trace('错误信息','error');
trace('日志信息','info');
也支持指定级别日志的输入，需要配置信息：

'log'   => [
    'type'  => 'File',
    // 日志记录级别，使用数组表示
    'level' => ['error'],
],
单文件日志
在某些情况下，需要对日志记录进行分析和处理，那么开启单文件日志写入就会方便分析。

'log'   => [
    'type'  => 'File',
    // 日志记录级别，使用数组表示
    'single' => true,
],
开启后，日志文件不再区分日期文件写入，而是统一写入到single.log文件中。

日志自动清理
V5.0.16+版本开始，支持文件日志的自动清理功能，你可以设置

'max_files'	=> 30
则日志文件最多只会保留30个，超过会自动清理较早的日志文件，避免日志文件长期写入占满磁盘空间。

开启自动清理功能后，不会生成日期子目录。
### 独立日志
为了便于分析，File类型的日志驱动还支持设置某些级别的日志信息单独文件记录，例如：

'log'   => [
    'type'          => 'file', 
    // error和sql日志单独记录
    'apart_level'   =>  ['error','sql'],
],
设置后，就会单独生成error 和 sql两个类型的日志文件，主日志文件中将不再包含这两个级别的日志信息。

独立日志文件按天保存，不限制大小。
如果开启了单文件日志写入的话，独立日志不会区分日期目录写入。

### 日志清空
日志类提供了日志清空的方法，可以在需要的时候手动清空日志，日志清空仅仅是清空内存中的日志。

使用方法如下：

Log::clear();

### 写入授权
5.0的日志功能支持写入授权，我们可以设置某个请求的日志授权Key，然后设置允许授权写入的配置Key，实现个别用户日志记录的功能，从而提高高负载下面的日志记录性能。

首先需要在应用配置文件或者应用公共文件中添加当前访问的授权Key定义，例如：

// 设置IP为授权Key
Log::key(Request::instance()->ip());
然后在日志配置参数中增加allow_key参数，如下：

'log'   =>  [
    // 日志类型为File
    'type'      =>  'File',
    // 授权只有202.12.36.89 才能记录日志
    'allow_key' =>  ['202.12.36.89'],
]

#### 验证
### 验证器
ThinkPHP5.0验证使用独立的\think\Validate类或者验证器进行验证。
## 独立验证
任何时候，都可以使用Validate类进行独立的验证操作，例如：

$validate = new Validate([
    'name'  => 'require|max:25',
    'email' => 'email'
]);
$data = [
    'name'  => 'thinkphp',
    'email' => 'thinkphp@qq.com'
];
if (!$validate->check($data)) {
    dump($validate->getError());
}

## 验证器
这是5.0推荐的验证方式，为具体的验证场景或者数据表定义好验证器类，直接调用验证类的check方法即可完成验证，下面是一个例子：

我们定义一个\app\index\validate\User验证器类用于User的验证。

namespace app\index\validate;

use think\Validate;

class User extends Validate
{
    protected $rule = [
        'name'  =>  'require|max:25',
        'email' =>  'email',
    ];

}
在需要进行User验证的地方，添加如下代码即可：

$data = [
    'name'=>'thinkphp',
    'email'=>'thinkphp@qq.com'
];

$validate = Loader::validate('User');

if(!$validate->check($data)){
    dump($validate->getError());
}
使用助手函数实例化验证器

$validate = validate('User');

### 验证规则
$rule = [
    'name'  => 'require|max:25',
    'age'   => 'number|between:1,120',
    'email' => 'email',
];

$msg = [
    'name.require' => '名称必须',
    'name.max'     => '名称最多不能超过25个字符',
    'age.number'   => '年龄必须是数字',
    'age.between'  => '年龄只能在1-120之间',
    'email'        => '邮箱格式错误',
];

$data = [
    'name'  => 'thinkphp',
    'age'   => 10,
    'email' => 'thinkphp@qq.com',
];

$validate = new Validate($rule, $msg);
$result   = $validate->check($data);
if(!$result){
    echo $validate->getError();
}

验证器的使用
validate(文件夹) -> AdminUser.php
<?php
	namespace app\admin\validate;
	use think\Validate;
	class AdminUser extends Validate
	{
		protected $rule = [
			"username|用户名" => "require|max:16",
			"email|邮箱" => "require|email",
			"__token__" => "token|require"
		];
		portected $message = [
			"__token__.require" => "请不要进行非法操作"
		];
		protected $scens = [
			'status' => ['__token__', 'status' => 'require|number'],
			'login' => ['usernmae', 'password|密码' => 'require', '__token__'],
			'user' => ['password|密码' => 'require', '__token__'],
			'del' => ['__token__']
		];

	}
?>






#### 使用网络和协议函数
面向网络的函数：支持与互联网进行交互。
互联网提供了大量的资源，可以通过许多许多协议使用这些资源
协议是在特定场景下进行交流的规则
不同的计算机协议适用于不同的场景和应用
HTTP（超文本传输协议）、FTP（文件传输协议）、
大多数协议和互联网标准都是以文档方式描述，称作 Request for Comments（RFC），这些协议由国际互联网工程组（IETF）制定  http://www.rfcOeditor.org
使用 SMTP 发动邮件，使用 POP3 和 IMAP4 读取邮件，通过 HTTP 连接 web 服务器 ，使用 FTP 传输文件
SMTP 只能用来发邮件 
IMAP4 用来读取和操作保存在服务器上的邮件
POP3 可以将邮件消息下载至客户端并从服务器端删除   http://php.net/manual/en/book.imap.php


class UserModel extends Model
{
    // 确定链接表名
    protected $name = 'user';

    /**
     * 根据搜索条件获取用户列表信息
     * @param $where
     * @param $offset
     * @param $limit
     */
    public function getUsersByWhere($where, $offset, $limit)
    {
        return $this->alias('user')->field( 'user.*,role_name')
            ->join('role rol', 'user.role_id = ' . 'rol.id')
            ->where($where)->limit($offset, $limit)->order('user_id desc')->select();
    }
}


#### TP5中的request常用方法 
$request->module()
$request->controller()
$request->action()
$request->method()
$request->ip()
$request->isAjax()
$request->domain()		// 当前域名  
$request->baseFile()  	// 当前入口文件   
$request->url(true)	 	// 包涵域名的完整的url地址       
$request->query()		// URL地址的参数信息   
$request->baseUrl()  	// 当前URL地址  不含qurey_string     
$request->pathinfo()   	// URL中的pathinfo信息  
$request->ext()  		// URL地址中的后缀信息    比如http://www.baidu.com/index.html 则返回html


if($this->$request->isAjax()){
	$data = $this->request->post();
}


导航放到跟控制器同级的config文件中
return [
    'admin/users' => [
        'name' => '会员管理',
        'action' => [
            'user' => '会员列表',
            'user_form' => '添加修改会员',
            'user_del' => '会员删除',
            'user_status' => '会员状态修改',
        ]
    ],
    'admin/component' => [
        'name' => '插件管理',
        'action' => [
            'plugin' => '插件列表',
            'plugin_form' => '添加修改插件',
            'status' => '修改插件状态',
            'alipay' => '调用支付宝支付示例',
            'wxpay' => '调用微信支付示例',
            'alisms' => '调用短信示例',
            'kdniao' => '查看物流信息',
        ]
]
引用  $nav = config('navigate.');

$module = $this -> request -> module();
$controller = $this -> request -> controller();
$action = $this -> request -> action();

$navigate = [];
foreach($nav as $k => $v){
	$round = strtolower($module).'/'.strtolower($controller);
	if($round == $k){
		$navigate[] = $v['name'];
		foreach($v['action'] as $key => $value){
			if($strtolower($key) == strtolower($action)){
				$valigate[] = $value;
			}
		}
	}
}

$navigate = [];
foreach($nav as $k => $v){
	$round = strtolower($module) . '/' . strtolower($controller);
	if($k == $round){
		$navigate[] = $v['name'];
		foreach($v['action'] as $key => $val){
			if(strtolower($action) == strtolower($key)){
				$navigate[] = $val;
			}
		}
	}
}


#### tp5 数据库
Db::table(think_user)->where('id',1)->find();   // table 表必须带前缀
Db::name(user)->								// 如果设置了数据表前缀参数的话，可以使用
db('user')->									// 系统提供了一个db助手函数
find()
select()
value('username')
column('id','name')


$data = ['username'=>'zhang','password'=>'admin'];
Db::name(user)->insert($data);
Db::name('user')->strict(false)->insert($data);  // 不希望抛错
$userId = Db::name('user')->insertGetId($data);

Db::name('user')->insertAll($data);
如果要更新的数据需要使用SQL函数或者其它字段，可以使用下面的方式：
Db::name('user')
    ->where('id',1)
    ->inc('read_time')
    ->dec('score',3)
    ->exp('name','UPPER(name)')
    ->update();

Db::table('think_user')->where('id','<',10)->delete();
Db::name('user')->where('id','<>',100)->select();      // 不等于
Db::name('user')->where('username','like','ing%')->select();

Db::name('user')->where('name','like',['%think','php%'],'OR')->select();
SELECT * FROM `think_user` WHERE  (`name` LIKE '%think' OR `name` LIKE 'php%')

Db::name('user')->whereLike('name','thinkphp%')->select();
Db::name('user')->whereNotLike('name','thinkphp%')->select();

Db::name('user')->where('id','between','1,8')->select();
Db::name('user')->whereBetween('id','1,8')->select();

Db::name('user')->where('id','in','1,5,8')->select();
Db::name('user')->whereIn('id','1,5,8')->select();

Db::name('user')->where('name', null)->where('email','null')->where('name','not null')->select();
Db::name('user')->whereNull('name')->whereNull('email')->whereNotNull('name')->select();

Db::name('user')->where('id','in','1,3,8')->select();
Db::name('user')->where('id','exp',' IN (1,3,8) ')->select();

HAVING方法用于配合group方法完成从分组的结果中筛选（通常是聚合条件）数据。
Db::table('think_user')
    ->field('username,max(score)')
    ->group('user_id')
    ->having('count(test_time)>3')
    ->select(); 



$OrderGoods -> startTrans();

$OrderGoods -> rollback();

$OrderGoods -> commit();

#### MySQL 高级管理

深入理解权限系统
提升MySQL数据库安全
获取数据库更多信息
使用索引加速查询
优化数据库
备份和回复
实现复制

使用 GRANNT 命令进行授权
当执行 GRANT 语句时，他将影响存在于特殊数据库(mysql)的表，权限信息存储在mysql数据库的7张表中
在授权时，必须关注对mysql数据库访问权限的控制
权限表:确定用户可以执行的操作  user、host、db、table_priv、columns_priv、proxies_priv、proc_prov
如果手工修改权限时，需要告诉服务器已经发生了一次权限修改
1、flush privileges;
2、mysqladmin privileges;
3、mysqladmin reload;
然后服务器重启


如果不是必须的，不能将 PROCESS  FILE  SUPER  SHUTDOWN  RELOAD  授权给非管理员用户，如果必须，可以控制使用权限
PROCESS 权限可以用来查看用户执行的操作以及输入的数据，包括密码
FILE 权限用来在MySQL服务器和操作系统之间读写文件
SUPER 权限用来终止链接、修改系统变量以及控制复制
RELOAD 权限用来重新载入授权表







#### MySQL 高级编程
表类型、事务、储存过程
LOAD DATA INRILE 语句
储存引擎
事务
外键
储存过程

### LOAD DATA INFILE 语句
可以使用该语句从文件载入数据，他的执行速度非常快
LOAD DATA INFILE "newbooks.txt" INTO TABLE books;  // 将newbooks.txt文件数据读写到books
LOAD DATA INFILE 是 SELECT ... INTO OUTFILE 的相对语句


### 存储引擎
MySQL支持大量不同的存储引擎，有事后也称作白哦类型，数据库每张表可以使用不同的存储引擎，引擎之间也可以相互转换
CREATE TABLE table TYPE=type...
常见可用引擎如下：
### InnoDB：MySQL默认，这些表是事务安全的，提供了COMMIT和ROLLBACK能力，也支持外键，此类型具备最佳的读写性能，部分原因是气支持行级锁定；
### MyISAM：MySQL早期默认形式，典型使用场所是数据仓库应用，全文索引支持得到提高，暂时优于InnoDB
### MEMORY：临时表或者需要使用视图可以使用MEMORY表，
### MERGE：需要处理大型MyISAMySQL表，可以使用MERGE表
### ARCHIVE
### CSV
修改表类型：ALTER TABLE Orders ENGING=InnoDb;

### 事务
一个或者一组查询，这些查询必须确保在数据库上完全执行或者完全不执行
在事务完成或者未完成后，数据库可以保持一致状态
## 原子性
## 一致性
## 隔离性（1、读未提交 2、授权读取（已提交读）（不可重复读）3、可重复读 4、串行化）
## 持久性

## 使用 InnoDB 事务
默认情况下，MySQL以自动提交模式运行  
要关闭自动提交功能 SET AUTOCOMMIT=0;
如果autocommit处于开启状态，需要使用 START TRANSACTION;  开始一个事务
如果autocommit处于关闭状态，当输入SQL语句时，事务将自动提交
COMMIT;
ROLLBACK;

### 外键
CREATE TABLE Order_Items
(
	OrderID INT UNSIGNED NOT NULL,
	ISBN CHAR(13) NOT NULL,
	Quantity TINYINT UNSIGNED,
	PRIMARY KEY (OrderID,ISBN),
	FOREIGN KEY (OrderID) REFERENCES Orders(OrderID),
	FOREIGN KEY (ISBN) REFERENCES Books(ISBN)
);

### 存储过程
存储过程是一个 程序化 函数，该函数 只能在 MySQL中 创建 和 保存，由 SQL语句 及 相应的 特殊控制结构 组成。
在 不同的 应用 或 平台 重复执行 相同功能 或 封装代码功能 场景下，储存过程将非常有用
数据库中的储存过程可以看作编程中的面向对象方法，它可以控制数据访问方式
## 储存过程的声明
# Base stored procedure example
DELIMITER //											// 结束标记符修改为 "//"(如果没有修改，语句结束标记符通常是 ";"),这样做的目的是可以在储存过程中使用分号，
CREATE PROCEDURE Total_Orders (OUT Total FLOAT)			// 创建储存过程  Total_Orders为储存名，需要一个Total参数，
BEGIN
SELECT SUM(Amount) INTO Total FROM Orders;				// 过程体
END
DELIMITER ;

## 创建函数
# Basic syntax to create a function
DELIMITER //
CREATE FUNCTION Add_Tax (Price FLOAT) RETURNS FLOAT NO SQL    // FUNCTION 代替 PROCEDURE,不需要指定IN或者OUT，因为函数参数必须为输入，"RETURNS FLOAT"指定返回类型,"NO SQL"为关键字
	RETURN Price*1.1;
//
DELIMITER ;

SHOW CREATE PROCEDURE 储存过程名
SHOW CREATE FUNCTION 函数名
DROP CREATE PROCEDURE 储存过程名
DROP CREATE FUNCTION 函数名

## 本地变量 declare

## 游标和控制器结构

### 触发器
触发器的常见用途是：重新格式化数据，通过日志记录修改内容，修改发生时间，执行修改的用户





